,Unnamed: 0,question,correct_answer,context,answer_8b,Rouge1,Rouge2,RougeL,Bleu,Chrf,ChrfPlus,Meteor,Ter,Bert,WMS,SMS,Wisdm,Bart,BEM,Prometheus,Consistency,TSim,Faithfullness,Relevancy,Correctness,RSim,LLM,Bleurt
0,0,How do these automated metrics for human preferences differ and what factors do they consider when predicting human preferences?,"The automated metrics that are mentioned while discussing related work are BERTScore (Zhang et al., 2019), BLEURT (Sellam et al., 2020), and Ouyang et al (2022). More information on these automated metrics, including the differences between them, can probably be gleaned by reading these cited works. The current paper does not contain any additional information about these related automated metrics.","The ultimate aim of language technology is to interact with humans.However, most language models are trained without direct signals of human preference,with supervised target strings serving as (a sometimes crude) proxy.One option to incorporate user feedback is via human-in-the-loop, i.e., a user would be expected to provide feedback for each sample online as the model trains, but this degree of dense supervision is often prohibitive and inefficient.Automated metrics offer a promising compromise: learned models of human preference like BERTScore (Zhang et al., 2019), BLEURT (Sellam et al., 2020), summarization preferences (Wu et al., 2021) have significantly improved correlation with human judgment compared to earlier metrics (BLEU, METEOR, etc.), and are cheap to evaluate. But — these functions are usually not per-token differentiable: like humans, metrics can only offer quality estimates for full generations.Reinforcement Learning (RL) offers a natural path forward for optimizing non-differentiable, scalar objectives for LM-based generation when it is cast as a sequential decision-making problem. However, Goodhart’s Law222Strathern (1997) paraphrases: When a measure becomes a target, it ceases to be a good measure.looms: particularly in the case of imperfect metrics that use neural networks, it is easy to find nonsense samples that achieve high-quality estimates. Recent works have shown promising results in aligning LMs to human preferences via RL by constraining preference-based rewards to incorporate notions of fluency (Wu et al., 2021; Ouyang et al., 2022) but progress in this line of work is heavily hindered by a lack of open-source benchmarks and algorithmic implementations—resulting in perception that RL is a challenging paradigm for NLP (Choshen et al., 2020; Kreutzer et al., 2021).","They differ in their approaches and factors considered, such as:

- BERTScore: uses contextualized embeddings and cosine similarity
- BLEURT: uses a transformer-based model and learns to predict human ratings
- Summarization preferences: focuses on evaluating summarization quality and considers factors like fluency and relevance.",0.0470588186131493,0.0,0.0470588186131493,0.732982310966735,27.61620097936934,22.08102761575129,0.0550964187327823,0.0075693860386879,0.4354608058929443,0.3615888689270837,0.4201249778270721,0.3245430886745453,0.0066815568653514,0.0599211752414703,3,1.0,4.0,1.0,0.8402088219566384,0.7204943646976659,0.8819774587906638,0.9,0.0599211752414703
1,1,What does non-differentiable mean here? If the problem with previous metrics is that they are not per-token differentiable then why are they looking for a way to optimize non-differentiable objectives?,"A formal definition of non-differentiability has not been provided by the authors. However, authors in this context use this idea of differentiability to explain that most automated metrics cannot provide quality estimates after a language model generates one token or a parietal output - similar to humans, they can provide quality estimates only after a language model generates a full sequence. This non-differentiability is pointed out as a problem by the authors for the new metrics (i.e. things like BLUERT or BERTScore) - it is unclear from this paper alone if previous vanilla metrics (i.e. BLEU) were per token differentiable or not. The authors are looking for ways to use these non-differentiable scores in RL frameworks, potentially as a reward function.","The ultimate aim of language technology is to interact with humans.However, most language models are trained without direct signals of human preference,with supervised target strings serving as (a sometimes crude) proxy.One option to incorporate user feedback is via human-in-the-loop, i.e., a user would be expected to provide feedback for each sample online as the model trains, but this degree of dense supervision is often prohibitive and inefficient.Automated metrics offer a promising compromise: learned models of human preference like BERTScore (Zhang et al., 2019), BLEURT (Sellam et al., 2020), summarization preferences (Wu et al., 2021) have significantly improved correlation with human judgment compared to earlier metrics (BLEU, METEOR, etc.), and are cheap to evaluate. But — these functions are usually not per-token differentiable: like humans, metrics can only offer quality estimates for full generations.Reinforcement Learning (RL) offers a natural path forward for optimizing non-differentiable, scalar objectives for LM-based generation when it is cast as a sequential decision-making problem. However, Goodhart’s Law222Strathern (1997) paraphrases: When a measure becomes a target, it ceases to be a good measure.looms: particularly in the case of imperfect metrics that use neural networks, it is easy to find nonsense samples that achieve high-quality estimates. Recent works have shown promising results in aligning LMs to human preferences via RL by constraining preference-based rewards to incorporate notions of fluency (Wu et al., 2021; Ouyang et al., 2022) but progress in this line of work is heavily hindered by a lack of open-source benchmarks and algorithmic implementations—resulting in perception that RL is a challenging paradigm for NLP (Choshen et al., 2020; Kreutzer et al., 2021).","In this context, ""non-differentiable"" refers to objectives that cannot be optimized using backpropagation, a method that requires the objective to be differentiable.

They are looking to optimize non-differentiable objectives because previous metrics (like BERTScore and BLEURT) are not per-token differentiable, but they are scalar objectives (i.e., they provide a single score for a full generation).",0.2900763313210186,0.0359281392549039,0.2900763313210186,4.8981354240795945,43.72947936181828,38.29283025701703,0.1558846453624318,0.0049751243781094,0.7400004863739014,0.5167347417590733,0.662574976682663,0.6822770237922668,0.0317510924015216,0.218283474445343,4,0.75,2.0,1.0,0.882265242129502,0.4752881822772107,0.9011527291088428,0.0,0.218283474445343
2,2,"Why is the action space of language modeling particularly large? Is it because of the vocab size? But then, moving in the real world also has a huge action space (degrees of movement).","The action space for language modeling is equal to the vocabulary set of language models. Since the vocabularies are very large (i.e. tens of thousands of possible tokens), the action space is also very large. In general, locomotion in the real world can be condensed to three quantities - moving across X, Y or Z axes, or a linear combination thereof. The authors mention that typical RL problems have an action space that is an order of magnitude smaller, but do not specifically explain how the action spaces for typical problems is modeled or constructed.","Language generation action spaces are orders of magnitude larger than what most discrete action space RL algorithms are designed for (Ranzato et al., 2015; Ammanabrolu, 2021), e.g., GPT-2/3 and T5 have a vocabulary size of 50K and 32K respectively.We hypothesize that the size of the action space is a core cause of instability when training LMs with existing RL methods.To address this issue, we introduce NLPO (Natural Language Policy Optimization), which is inspired by work on action elimination/invalid-action masking (Zahavy et al., 2018; Huang & Ontañón, 2020; Ammanabrolu & Hausknecht, 2020). NLPO, a parameterized-masked extension of PPO, learns to mask out less relevant tokens in-context as it trains. NLPO accomplishes this via top-p sampling, which restricts tokens to the smallest possible set whose cumulative probability is greater than the probability parameter p (Holtzman et al., 2018).
RL for Large Action Spaces. MIXER (Ranzato et al., 2015) combined ideas from schedule sampling and REINFORCE (Williams, 1992).Bahdanau et al. (2016) proposed an actor-critic algorithm to address the variance/large action space problems when using REINFORCE for language generation; follow-up works such asKG-A2C (Ammanabrolu & Hausknecht, 2020), TrufLL (Martin et al., 2022), AE-DQN (Zahavy et al., 2018), and GALAD (Ammanabrolu et al., 2022) addressed similar issues by attempting to eliminate and reduce the action space during exploration.
Each environment is an NLP task: we are given a supervised dataset \mathcal{D}=\{({\bm{x}}^{i},{\bm{y}}^{i})\}_{i=1}^{N} of N examples, where {\bm{x}}\in\mathcal{X} is an language input and {\bm{y}}\in\mathcal{Y} is the target string. Generation can be viewed as a Markov Decision Process (MDP) \langle\mathcal{S},\mathcal{A},\mathcal{R},P,\gamma,T\rangle using a finite vocabulary \mathcal{V}.Each episode in the MDP begins by sampling a datapoint ({\bm{x}},{\bm{y}}) from our dataset and ends when the current time step t exceeds the horizon T or an end of sentence (EOS) token is generated.The input {\bm{x}}=(x_{0},\cdots,x_{m}) is a task-specific prompt that is used as our initial state \bm{s}_{0}=(x_{0},\cdots,x_{m}), where \bm{s}_{0}\in\mathcal{S} and \mathcal{S} is the state space with x_{m}\in\mathcal{V}. An action in the environment a_{t}\in\mathcal{A} consists of a token from our vocabulary \mathcal{V}. The transition function P:\mathcal{S}\times\mathcal{A}\rightarrow\mathcal{S} deterministically appends an action a_{t} to the end of the state \bm{s}_{t-1}=(x_{0},\cdots,x_{m},a_{0},\cdots,a_{t-1}). This continues until the end of the horizon t\leq T and we obtain a state \bm{s}_{T}=(x_{0},\cdots,x_{m},a_{0},\cdots,a_{T}).At the end of an episode a reward \mathcal{R}:\mathcal{S}\times\mathcal{A}\times\mathcal{Y}\rightarrow\mathbb{R}^{1} that depends on the (\bm{s}_{T},{\bm{y}}) (e.g., an automated metric like PARENT Dhingra et al. (2019)) is emitted. RL4LMs provides an OpenAI gym (Brockman et al., 2016) styleAPI for an RL environmentthat simulates this LM-Based MDP formulation.Abstracting the details of the MDP environment structure allows for new tasks to be added quickly with compatibility across all implemented algorithms.","The action space of language modeling is particularly large because it involves predicting the next word in a sequence, where each word can be one of thousands of possibilities, resulting in an exponential increase in the number of possible actions.",0.3137254858189158,0.1538461496461539,0.274509799544406,4.009311499790002,41.05289760097251,38.29041630253078,0.1748628230616302,0.0049140049140049,0.7977415919303894,0.7265199108765674,0.7919512391090393,0.7603963613510132,0.0555125882985712,0.1382855772972107,4,1.0,4.0,0.6666666666666666,0.8998951466023383,0.6042955516955578,0.9171823225989502,0.0,0.1382855772972107
3,3,What are actor-critic algorithms and how do they differ to other RL algorithms like Q-learning?,Actor critic models are a class of reinforcement learning algorithms. The paper does not contain information on Q-learning or how actor critic models are different from Q-learning models.,"RL4LMs supports fine-tuning and training LMs from scratch via on-policy actor-critic algorithms on language environments.Formally, this class of algorithms allows us to train a parameterized control policy defined as \pi_{\theta}:\mathcal{S}\rightarrow\mathcal{A}, a function that attempts to select an action in a given state so as to maximize long term discounted rewards over a trajectory \mathbb{E}_{\pi}[\sum_{t=0}^{T}\gamma^{t}\mathcal{R}(\bm{s}_{t},a_{t})].Our benchmark experiments focus on fine-tuning a pre-trained LM denoted as \pi_{0} from which we initial our agent’s policy \pi_{\theta}=\pi_{0}.Similarly, the value network V_{\phi} used to estimate the value function is also initialized from \pi_{0} except for the final layer which is randomly initialized to output a single scalar value.As with other deep RL actor-critic algorithms, we define our value and Q-value functions as V_{t}^{\pi}=\mathbb{E}_{a_{t}\sim\pi}[\sum_{\tau=t}^{T}\gamma R(\bm{s}_{\tau},a_{\tau},{\bm{y}})],Q_{t}^{\pi}(\bm{s}_{t},a_{t})=R(\bm{s}_{t},a_{t},{\bm{y}})+\gamma\mathbb{E}_{s_{t+1}\sim P}[V_{t+1}^{\pi}(\bm{s}_{t+1})]leading to a definition of our advantage function as A_{t}^{\pi}(\bm{s},a)=Q_{t}^{\pi}(\bm{s},a)-V_{t}^{\pi}.To increase training stability, advantage is appoximated using Generalized Advantage Estimation (Schulman et al., 2015).","Actor-critic algorithms combine policy-based and value-based methods. They estimate both the policy (actor) and value function (critic) simultaneously, unlike Q-learning which only estimates the value function.",0.0888888838913583,0.0,0.0888888838913583,1.7581385995646757,26.757195494047,21.69411466238257,0.1155115511551155,0.0095377842993396,0.8489387035369873,0.648906413860181,0.8011572957038879,0.711693525314331,0.0365321376758015,0.4298233687877655,4,0.6666666666666666,4.0,,0.9001029784439316,0.6487525811325209,0.8807246102443693,0.0,0.4298233687877655
4,4,What do the equations for Q-value and value represent?,"Q and V are mathematically expressed as: V_{t}^{\pi}=\mathbb{E}_{a_{t}\sim\pi}[\sum_{\tau=t}^{T}\gamma R(\bm{s}_{\tau},a_{\tau},{\bm{y}})],Q_{t}^{\pi}(\bm{s}_{t},a_{t})=R(\bm{s}_{t},a_{t},{\bm{y}})+\gamma\mathbb{E}_{s_{t+1}\sim P}[V_{t+1}^{\pi}(\bm{s}_{t+1})] where R is the reward function, s means states, and the variable 'a' denotes actions. Further information on what these values mean, or their interpretation is not found in this paper.","RL4LMs supports fine-tuning and training LMs from scratch via on-policy actor-critic algorithms on language environments.Formally, this class of algorithms allows us to train a parameterized control policy defined as \pi_{\theta}:\mathcal{S}\rightarrow\mathcal{A}, a function that attempts to select an action in a given state so as to maximize long term discounted rewards over a trajectory \mathbb{E}_{\pi}[\sum_{t=0}^{T}\gamma^{t}\mathcal{R}(\bm{s}_{t},a_{t})].Our benchmark experiments focus on fine-tuning a pre-trained LM denoted as \pi_{0} from which we initial our agent’s policy \pi_{\theta}=\pi_{0}.Similarly, the value network V_{\phi} used to estimate the value function is also initialized from \pi_{0} except for the final layer which is randomly initialized to output a single scalar value.As with other deep RL actor-critic algorithms, we define our value and Q-value functions as V_{t}^{\pi}=\mathbb{E}_{a_{t}\sim\pi}[\sum_{\tau=t}^{T}\gamma R(\bm{s}_{\tau},a_{\tau},{\bm{y}})],Q_{t}^{\pi}(\bm{s}_{t},a_{t})=R(\bm{s}_{t},a_{t},{\bm{y}})+\gamma\mathbb{E}_{s_{t+1}\sim P}[V_{t+1}^{\pi}(\bm{s}_{t+1})]leading to a definition of our advantage function as A_{t}^{\pi}(\bm{s},a)=Q_{t}^{\pi}(\bm{s},a)-V_{t}^{\pi}.To increase training stability, advantage is appoximated using Generalized Advantage Estimation (Schulman et al., 2015).",The expected future rewards.,0.0,0.0,0.0,0.1618114504056441,9.871324940261186,8.348568871122186,0.0092307692307692,0.0009990009990009,0.4353075623512268,0.5012748815705267,0.4247996211051941,0.4146734774112701,0.0056224013604648,0.0794377923011779,3,1.0,1.0,1.0,0.7131486167642352,,0.7771206914362396,0.8,0.0794377923011779
5,5,Why is it helpful to mask out less relevant tokens if these are less likely to be sampled anyways?,"The authors hypothesize that their dynamic masking function helps because it adds a new constraint that the RL algorithm has to abide by. Additionally, since this is a dynamic function, being updated oftenly (every mu steps), it is likely that the masking function ensures that the selected top-p tokens are more relevant to the current state the RL algorithm needs to analyse and decide on.","Specifically, NLPOmaintains a masking policy \pi_{\psi}: the masking policy is a copy of the current policy (\pi_{\theta}), but is updated only every \mu steps.A parameterized-invalid-mask is created from \pi_{\psi} by first selecting the top-p tokens from the vocabulary,444\pi_{\psi} could be trained with alternate sampling techniques like top-k or beam search (or even hard-coded via rules by domain experts), though we find top-p sampling to be most effective in practice. and then applying an invalid-mask to the remaining tokens—i.e. setting their probabilities to zero when sampling actions from \pi_{\theta} during training;this periodic updating policy \pi_{\psi} is inspired by off-policy Q-learning algorithms (Andrychowicz et al., 2017),providing the policy \pi_{\theta} with an additional constraint that balances between the benefits of containing more task relevant information than the KL penalty derived from \pi_{0} and the risk of reward hacking.We provide pseudocode in Algorithm 1 (green portions highlight the differences with PPO).
PPO vs. NLPO.Figure 2 shows that NLPO generally outperforms PPO and supervised, especially when applied after supervised training.We hypothesize that the primary reason for NLPO’s improved performance and stability is because the masking policy provides an additional constraint for the current policy.This constraint is not based on the initial untuned policy like the KL penalty but of the policy from \mu iterations ago and likely contains more task-relevant information learned during RL training.Table 3 (and Appendix Table 8) shows how performance increases up to a point and then decreases as p in top-p sampling is increased for the masking policy, relaxing the constraint by eliminating less tokens at each step, implying that there is a balance to be found in how much the model should be constrained during RL training.",It helps balance task-relevant information and risk of reward hacking.,0.0689655143876338,0.0,0.0689655143876338,0.6600864627595707,21.67517305935496,17.897239645447865,0.0303490136570561,0.0015600624024961,0.2431493252515792,0.496621468737865,0.2054688334465026,0.2840109467506408,0.0040787836383919,0.08549465239048,3,1.0,1.0,1.0,0.7367280471795931,0.4953771483152621,0.7815085932610484,0.0,0.08549465239048
6,6,Why is the masking policy only updated every certain number of steps?,"The authors mention that they update the masking function every ""mu"" steps, but the main text of the paper itself does not appear to contain the exact value of mu itself - there is a possibility that the author's model could work with mu=1 instead (i.e. update every step) instead of updating it every couple of steps (i.e. mu > 1), though the authors do not explain in this paper if this were done. However, the authors mention that one reason why NLPO outperforms PPO is probably because of this dynamic masking function that is updated occasionally - this indicates to us that mu is probably not an unbounded or very large number (if mu were very large, tending to infinity, the function would no longer be dynamic).","Language generation action spaces are orders of magnitude larger than what most discrete action space RL algorithms are designed for (Ranzato et al., 2015; Ammanabrolu, 2021), e.g., GPT-2/3 and T5 have a vocabulary size of 50K and 32K respectively.We hypothesize that the size of the action space is a core cause of instability when training LMs with existing RL methods.To address this issue, we introduce NLPO (Natural Language Policy Optimization), which is inspired by work on action elimination/invalid-action masking (Zahavy et al., 2018; Huang & Ontañón, 2020; Ammanabrolu & Hausknecht, 2020). NLPO, a parameterized-masked extension of PPO, learns to mask out less relevant tokens in-context as it trains. NLPO accomplishes this via top-p sampling, which restricts tokens to the smallest possible set whose cumulative probability is greater than the probability parameter p (Holtzman et al., 2018).
Specifically, NLPOmaintains a masking policy \pi_{\psi}: the masking policy is a copy of the current policy (\pi_{\theta}), but is updated only every \mu steps.A parameterized-invalid-mask is created from \pi_{\psi} by first selecting the top-p tokens from the vocabulary,444\pi_{\psi} could be trained with alternate sampling techniques like top-k or beam search (or even hard-coded via rules by domain experts), though we find top-p sampling to be most effective in practice. and then applying an invalid-mask to the remaining tokens—i.e. setting their probabilities to zero when sampling actions from \pi_{\theta} during training;this periodic updating policy \pi_{\psi} is inspired by off-policy Q-learning algorithms (Andrychowicz et al., 2017),providing the policy \pi_{\theta} with an additional constraint that balances between the benefits of containing more task relevant information than the KL penalty derived from \pi_{0} and the risk of reward hacking.We provide pseudocode in Algorithm 1 (green portions highlight the differences with PPO).
PPO vs. NLPO.Figure 2 shows that NLPO generally outperforms PPO and supervised, especially when applied after supervised training.We hypothesize that the primary reason for NLPO’s improved performance and stability is because the masking policy provides an additional constraint for the current policy.This constraint is not based on the initial untuned policy like the KL penalty but of the policy from \mu iterations ago and likely contains more task-relevant information learned during RL training.Table 3 (and Appendix Table 8) shows how performance increases up to a point and then decreases as p in top-p sampling is increased for the masking policy, relaxing the constraint by eliminating less tokens at each step, implying that there is a balance to be found in how much the model should be constrained during RL training.",Inspired by off-policy Q-learning algorithms.,0.0,0.0,0.0,0.2364971758623134,7.745881350948089,6.203590446408626,0.0037878787878787,0.0003904724716907,0.1567557007074356,0.3927239601363865,0.1577156037092209,0.35097736120224,0.0107671727071708,0.0682154223322868,1,1.0,0.0,,0.7190982800352526,0.3807378638581484,0.7729514554325938,0.0,0.0682154223322868
7,7,How did the token-masking policy help in the results?,"The use of token-masking policy in the proposed method (NLPO) is theorized by the authors to have been a key reason on why it was able to outperform the PPO based model. They hypothesized that their masking function acts as a dynamic constraint added to the algorithm, that is able to more effectively filter and capture relevant information about the state thanks to its' dynamic nature.","Specifically, NLPOmaintains a masking policy \pi_{\psi}: the masking policy is a copy of the current policy (\pi_{\theta}), but is updated only every \mu steps.A parameterized-invalid-mask is created from \pi_{\psi} by first selecting the top-p tokens from the vocabulary,444\pi_{\psi} could be trained with alternate sampling techniques like top-k or beam search (or even hard-coded via rules by domain experts), though we find top-p sampling to be most effective in practice. and then applying an invalid-mask to the remaining tokens—i.e. setting their probabilities to zero when sampling actions from \pi_{\theta} during training;this periodic updating policy \pi_{\psi} is inspired by off-policy Q-learning algorithms (Andrychowicz et al., 2017),providing the policy \pi_{\theta} with an additional constraint that balances between the benefits of containing more task relevant information than the KL penalty derived from \pi_{0} and the risk of reward hacking.We provide pseudocode in Algorithm 1 (green portions highlight the differences with PPO).
PPO vs. NLPO.Figure 2 shows that NLPO generally outperforms PPO and supervised, especially when applied after supervised training.We hypothesize that the primary reason for NLPO’s improved performance and stability is because the masking policy provides an additional constraint for the current policy.This constraint is not based on the initial untuned policy like the KL penalty but of the policy from \mu iterations ago and likely contains more task-relevant information learned during RL training.Table 3 (and Appendix Table 8) shows how performance increases up to a point and then decreases as p in top-p sampling is increased for the masking policy, relaxing the constraint by eliminating less tokens at each step, implying that there is a balance to be found in how much the model should be constrained during RL training.","It provided an additional constraint for the current policy, balancing task-relevant information and reward hacking risk.",0.1159420254232305,0.0,0.0869565181768537,0.8275627201963309,33.816731659233575,28.46358946657641,0.06006006006006,0.0025740025740025,0.3305078744888305,0.6187104157287202,0.3849540650844574,0.4539547264575958,0.0059863223127003,0.1188160255551338,3,1.0,2.0,1.0,0.8571446453598138,0.801017917422078,0.8040739872727488,0.9,0.1188160255551338
8,8,What is the combinatorial action space? How is this different to general RL tasks? Are they not combinatorial?,"The combinatorial action space here probably refers to the set of all possible actions that a RL agent for optimizing a language model could possibly take - here, the action set consists of the entire vocabulary of the language model, which can range to tens of thousands for typical GPT/T5 models used today. This is unlike general RL tasks, where the action space is an order of magnitude smaller.","Language generation action spaces are orders of magnitude larger than what most discrete action space RL algorithms are designed for (Ranzato et al., 2015; Ammanabrolu, 2021), e.g., GPT-2/3 and T5 have a vocabulary size of 50K and 32K respectively.We hypothesize that the size of the action space is a core cause of instability when training LMs with existing RL methods.To address this issue, we introduce NLPO (Natural Language Policy Optimization), which is inspired by work on action elimination/invalid-action masking (Zahavy et al., 2018; Huang & Ontañón, 2020; Ammanabrolu & Hausknecht, 2020). NLPO, a parameterized-masked extension of PPO, learns to mask out less relevant tokens in-context as it trains. NLPO accomplishes this via top-p sampling, which restricts tokens to the smallest possible set whose cumulative probability is greater than the probability parameter p (Holtzman et al., 2018).
Each environment is an NLP task: we are given a supervised dataset \mathcal{D}=\{({\bm{x}}^{i},{\bm{y}}^{i})\}_{i=1}^{N} of N examples, where {\bm{x}}\in\mathcal{X} is an language input and {\bm{y}}\in\mathcal{Y} is the target string. Generation can be viewed as a Markov Decision Process (MDP) \langle\mathcal{S},\mathcal{A},\mathcal{R},P,\gamma,T\rangle using a finite vocabulary \mathcal{V}.Each episode in the MDP begins by sampling a datapoint ({\bm{x}},{\bm{y}}) from our dataset and ends when the current time step t exceeds the horizon T or an end of sentence (EOS) token is generated.The input {\bm{x}}=(x_{0},\cdots,x_{m}) is a task-specific prompt that is used as our initial state \bm{s}_{0}=(x_{0},\cdots,x_{m}), where \bm{s}_{0}\in\mathcal{S} and \mathcal{S} is the state space with x_{m}\in\mathcal{V}. An action in the environment a_{t}\in\mathcal{A} consists of a token from our vocabulary \mathcal{V}. The transition function P:\mathcal{S}\times\mathcal{A}\rightarrow\mathcal{S} deterministically appends an action a_{t} to the end of the state \bm{s}_{t-1}=(x_{0},\cdots,x_{m},a_{0},\cdots,a_{t-1}). This continues until the end of the horizon t\leq T and we obtain a state \bm{s}_{T}=(x_{0},\cdots,x_{m},a_{0},\cdots,a_{T}).At the end of an episode a reward \mathcal{R}:\mathcal{S}\times\mathcal{A}\times\mathcal{Y}\rightarrow\mathbb{R}^{1} that depends on the (\bm{s}_{T},{\bm{y}}) (e.g., an automated metric like PARENT Dhingra et al. (2019)) is emitted. RL4LMs provides an OpenAI gym (Brockman et al., 2016) styleAPI for an RL environmentthat simulates this LM-Based MDP formulation.Abstracting the details of the MDP environment structure allows for new tasks to be added quickly with compatibility across all implemented algorithms.","The combinatorial action space refers to the large vocabulary size of language models like GPT-2/3 and T5, which have 50K and 32K tokens respectively. This is different from general RL tasks, where action spaces are typically much smaller and discrete.",0.4318181769447314,0.1730769183894232,0.4090909042174588,12.077752155241118,51.98223574558675,48.05725809812245,0.2908189880020866,0.0073529411764705,0.9311327338218688,0.6824467748924112,0.8816083371639252,0.8450390100479126,0.0698277285751415,0.7681191563606262,4,0.6,4.0,,0.8868602810125387,0.4912230863024584,0.9648923452098336,0.8,0.7681191563606262
9,9,"For the images used for visualization in the paper, were they selected randomly or picked by the authors?","Authors best practices were to combine effects of different ways of regularization to produce interpretable images. They first search randomly through 300 different combinations of  hyperparameters, then they pick the best four sets of hyperparameters that are compliments to each other and then these sets would be used to visualize preferred images for different classes.","If the above regularization methods are applied individually, they aresomewhat effective at producing more interpretable images; Figure 3 shows the effects of each individual hyperparameter.However, preliminary experiments uncovered that their combinedeffect produces better visualizations. To pick a reasonable set ofhyperparameters for all methods at once, we ran a randomhyperparameter search of 300 possible combinations and settled on fourthat complement each other well. The four selected combinations arelisted in Table 1 and optimized images using each are shown for the “Gorilla” class output unit in Figure 4. Of the four, some show highfrequency information, others low frequency; some contain densepixel data, and others contain only sparse outlines of importantregions.We found the version in the lower-left quadrant to be the best single set of hyperparameters, but often greater intuition canbe gleaned by considering all four at once.Figure 5 shows the optimization results computed for a selection of units on all layers. A single image for every filter of all five convolutional layers is shown in Supplementary Figure S1. Nine images for each filter of all layers, including each of the 1000 ImageNet output classes, can be viewed at http://yosinski.com/deepvis.",picked by the authors.,0.042553189932096,0.0,0.042553189932096,0.7443018766188205,10.52675153958423,9.536528787120805,0.0379506641366223,0.000740192450037,0.2232687920331955,0.8761131167411804,0.2714451253414154,,0.0083991405601166,0.3214993774890899,3,0.0,1.0,0.0,0.8370352599241525,0.436909780159866,0.747639120639464,0.8,0.3214993774890899
10,10,Does the paper's DNN use a a larger width kernel or multiple smaller width kernels? ,The paper's DNN uses multiple smaller Gaussian kernels iteratively as a way of regularization during the optimization process as seen in equation 2 .,"Gaussian blur: Producing images via gradient ascent tends to produce examples with high frequency information (see Supplementary Section S1 for a possible reason). While these images cause high activations, they are neither realistic nor interpretable (Nguyen et al., 2014). A useful regularization is thus to penalize high frequency information. We implement this as a Gaussian blur step rθ (x) = GaussianBlur(x, θb width). Convolving with a blur kernel is more computationally expensive than the other regularization methods, so we added another hyperparameter θb every to allow, for example, blurring every several optimization steps instead of every step. Blurring an image multiple times with a small width Gaussian kernel is equivalent to blurring once with a larger width kernel, and the effect will be similar even if the image changes slightly during the optimization process. This technique thus lowers computational costs without limiting the expressiveness of the regularization. Mahendran & Vedaldi (2014) used a penalty with a similar effect to blurring, called total variation, in their work reconstructing images from layer codes.",Multiple smaller width kernels.,0.1538461512426036,0.0,0.1538461512426036,2.0705706652424007,37.72468132391003,32.554879360229336,0.1372282608695652,0.0018148820326678,0.457858145236969,0.8294286290248791,0.457858145236969,0.5628637671470642,0.0041242958147193,0.4672652781009674,3,0.5,4.0,0.0,0.7723464109976311,0.7090421285007459,0.8361685140029836,0.9,0.4672652781009674
11,11,Why did the authors choose the four particular regularizations instead of others?,"Authors mainly introduce four different and newly used regularizations that would help researchers in visualizing responses from different layers. These regularizations are designed to overcome different pathologies commonly encountered by gradient descent without regularization : L2 decay to penalize large pixel values which do not naturally occur, Gaussian blur:a useful regularization to iteratively penalize high frequency information associated with generated images via gradient ascent through each optimization step, Clipping pixels with small norm or Clipping pixels with small contribution.","We investigated the following four regularizations. All are designed to overcome different pathologies commonly encountered by gradient descent without regularization.
Gaussian blur: Producing images via gradient ascent tends to produce examples with high frequency information (see Supplementary Section S1 for a possible reason). While these images cause high activations, they are neither realistic nor interpretable (Nguyen et al., 2014). A useful regularization is thus to penalize high frequency information. We implement this as a Gaussian blur step r_{\theta}(\mathbf{x})=\mathrm{GaussianBlur}(\mathbf{x},\theta_{\mathrm{b\_width}}). Convolving with a blur kernel is more computationally expensive than the other regularization methods, so we added another hyperparameter \theta_{\mathrm{b\_every}} to allow, for example, blurring every several optimization steps instead of every step. Blurring an image multiple times with a small width Gaussian kernel is equivalent to blurring once with a larger width kernel, and the effect will be similar even if the image changes slightly during the optimization process. This technique thus lowers computational costs without limiting the expressiveness of the regularization. Mahendran & Vedaldi (2014) used a penalty with a similar effect to blurring, called total variation, in their work reconstructing images from layer codes.
The second tool — new regularizations that enable improved, interpretable, optimized visualizations of learned features — will help researchers and practitioners understand, debug, and improve their models. The visualizations also reveal a new twist in an ongoing story. Previous studieshave shown that discriminative networks can easily be fooled or hacked by the addition of certain structurednoise in image space (Szegedy et al., 2013; Nguyen et al., 2014).An oft-cited reason for this property is that discriminative training leads networksto ignore non-discriminative information in their input, e.g. learning to detect jaguars by matching the unique spots on their fur while ignoring the fact that they have four legs. For this reason it has been seen as a hopeless endeavor to create a generative model in which one randomly samples an x from a broad distribution on the space of all possible imagesand then iteratively transforms x into a recognizable image by moving it to a region that satisfies both a prior p(x) and posterior p(y|x) for some class label y.Past attempts have largely supported this view by producing unrealistic images using this method (Nguyen et al., 2014; Simonyan et al., 2013).
Paragraph 10 : L2 decay: A common regularization, L2 decay penalizes large values and is implemented as rθ (x) = (1−θdecay)·x. L2 decay tends to prevent a small number of extreme pixel values from dominating the example image. Such extreme single-pixel values neither occur naturally with great frequency nor are useful for visualization.
Paragraph 11 :Clipping pixels with small norm: The first two regularizations suppress high amplitude and high frequency information, so after applying both, we are left with an x∗ that contains somewhat small, somewhat smooth values. However, x∗ will still tend to contain non-zero pixel values everywhere. Even if some pixels in x∗ show the primary object or type of input causing the unit under consideration to activate, the gradient with respect to all other pixels in x∗ will still generally be non-zero, so these pixels will also shift to show some pattern as well, contributing in whatever small way they can to ultimately raise the chosen unit’s activation. We wish to bias the search away from such behavior and instead show only the main object, letting other regions be exactly zero if they are not needed.
Paragraph 12 : Clipping pixels with small contribution: Instead of clipping pixels with small norms, we can try something slightly smarter and clip pixels with small contributions to the activation.",To overcome different pathologies commonly encountered by gradient descent without regularization.,0.2597402572912802,0.2117647038062284,0.2597402572912802,10.334947296524636,48.98097083447299,46.499362274574985,0.1447876447876447,0.0015916654608594,0.562576174736023,0.846938775510204,0.6766024827957153,0.4931896924972534,0.286312540033853,0.2116671949625015,3,0.6666666666666666,2.0,1.0,0.8978125912073146,0.5959619349562013,0.883847739824805,0.8,0.2116671949625015
12,12,"What is meant by ""linear sweep"" in hyperparameter space?",linear sweep can be seen as a regular increment in the values of some regularization hyperparameter (from leftmost where there is no regularization to rightmost where strong regularization occur ) to see the variation of their effects on the corresponding activations.,"Figure 3. The effects of each regularization method from Section 3 when used individually. Each of the four rows shows a linear sweep in hyperparameter space from no regularization (left) to strong regularization (right). When applied too strongly, some regularizations cause the optimization to fail (e.g. L2 decay, top row) or the images to be less interpretable (small norm and small contribution clipping, bottom two rows). For this reason, a random hyperparameter search was useful for finding joint hyperparameter settings that worked well together (see Figure 4). Best viewed electronically, zoomed in.",A gradual increase in hyperparameter values from no regularization to strong regularization.,0.3111111074172839,0.1176470554402153,0.2666666629728395,4.743866035456086,52.48137813737389,48.067749802142856,0.1996900826446281,0.003516998827667,0.4982963800430298,0.7755276624577495,0.4982963502407074,0.4975306689739227,0.127450026887516,0.252140611410141,4,1.0,4.0,1.0,0.888603141261414,0.9701766821923632,0.880653894842793,0.8,0.252140611410141
13,13,What are the examples of the tools that enable understanding of Neural Networks for newcomers in deep learning? ,"The paper talked about two main tools; the first is a software tool to plot activations of each trained layer of a network, for images or videos. Second is introducing new regularization ways to help with understanding learned features through network.These tools are supposed to help newcomers in deep learning to have better intuitions for hidden interpretations of well known structures and give motivations for more new ideas.","The first tool is software that interactively plots the activations produced on each layer of a trained DNN for user-provided images or video. Static images afford a slow, detailed investigation of a particular input, whereas video input highlights the DNNs changing responses to dynamic input. At present, the videos are processed live from a user’s computer camera, which is especially helpful because users can move different items around the field of view, occlude and combine them, and perform other manipulations to actively learn how different features in the network respond.
The second tool — new regularizations that enable improved, interpretable, optimized visualizations of learned features — will help researchers and practitioners understand, debug, and improve their models. The visualizations also reveal a new twist in an ongoing story. Previous studieshave shown that discriminative networks can easily be fooled or hacked by the addition of certain structurednoise in image space (Szegedy et al., 2013; Nguyen et al., 2014).An oft-cited reason for this property is that discriminative training leads networksto ignore non-discriminative information in their input, e.g. learning to detect jaguars by matching the unique spots on their fur while ignoring the fact that they have four legs. For this reason it has been seen as a hopeless endeavor to create a generative model in which one randomly samples an x from a broad distribution on the space of all possible imagesand then iteratively transforms x into a recognizable image by moving it to a region that satisfies both a prior p(x) and posterior p(y|x) for some class label y.Past attempts have largely supported this view by producing unrealistic images using this method (Nguyen et al., 2014; Simonyan et al., 2013).",Interactive visualization tools and new regularizations for improved model understanding.,0.1470588210207612,0.0,0.1470588210207612,0.7633196857840644,36.0027739790232,30.32194253087416,0.0531107738998482,0.0015360983102918,0.4662289321422577,0.7335940113960189,0.4206806421279907,0.7097293138504028,0.0285677203520811,0.1962718665599823,3,1.0,4.0,0.3333333333333333,0.8621424179160107,0.5942056349747113,0.8767457631748053,0.8,0.1962718665599823
14,14,How did the authors compute the contributions of the pixels in order to clip the pixels with smaller contributions?,"Calculating absolute difference between some neuron activation of an input and the activation for same input without certain pixel can be considered a way of measuring the contribution of that pixel in the total response of the neuron. To ensure faster computation, we can estimate activation near the input with 1st order approximation (linear) and hence this leads  to total contribution estimated as the element wise product of the activation gradient and the input x (each element in this product shows how this pixel affects the total response ), we repeat this product for all different channels ,sum them all, and take absolute value  to find pixels with small contribution in either direction, positive or negative to get rid of.","Clipping pixels with small contribution: Instead of clipping pixels with small norms, we can try something slightly smarter and clip pixels with small contributions to the activation. One way of computing a pixel’s contribution to an activation is to measure how much the activation increases or decreases when the pixel is set to zero; that is, to compute the contribution as |a_{i}(\mathbf{x})-a_{i}(\mathbf{x}_{-j})|, where \mathbf{x}_{-j} is \mathbf{x} but with the j^{th} pixel set to zero. This approach is straightforward but prohibitively slow, requiring a forward pass for every pixel. Instead, we approximate this process by linearizing a_{i}(\mathbf{x}) around \mathbf{x}, in which case the contribution of each dimension of \mathbf{x} can be estimated as the elementwise product of \mathbf{x} and the gradient. We then sum over all three channels and take the absolute value, computing \left|\sum_{c}\mathbf{x}\circ\nabla_{\mathbf{x}}a_{i}(\mathbf{x})\right|. We use the absolute value to find pixels with small contribution in either direction, positive or negative. While we could choose to keep the pixel transitions where setting the pixel to zero would result in a large activation increase, these shifts are already handled by gradient ascent, and here we prefer to clip only the pixels that are deemed not to matter, not to take large gradient steps outside the region where the linear approximation is most valid. We define this r_{\theta}(\mathbf{x}) as the operation that sets pixels with contribution under the \theta_{\mathrm{c\_pct}} percentile to zero.",They approximated the contribution by linearizing the activation around the input and using the elementwise product of the input and the gradient.,0.177777775,0.1068702265275916,0.1333333305555556,2.6176754749845443,41.76814414249434,38.18897613905119,0.0915543811662212,0.0020518559970154,0.6296030879020691,0.843414252712613,0.6510466933250427,0.7552883625030518,0.0699955275763511,0.1338710784912109,3,1.0,4.0,,0.8835055543189135,0.7136777552447024,0.85471102097881,0.9,0.1338710784912109
15,15,"How does a ""network-centric"" approach differ from a ""dataset-centric approach""?","""Dataset-centric approach"" requires the trained network together with some dataset  to run through the network showing high or low responses of different units while interacting with most significant images of such dataset. This approach can also use deconvolution layers and upsampling to map and highlight the regions of an image that were responsible of the firing of the different units.
""Network-centric approach"" deals only with network without the need to any dataset.You can start with some initial input, compute activations through the forward path and then compute gradients while backprop. You can then ascent or descent the input towards gradient until you reach a preferred input stimulus x* for the unit under consideration. Working with input images, you can visualize that x* if you want.","Another approach is to try to interpret the function computed by each individual neuron. Past studies in this vein roughly divide into two different camps: dataset-centric and network-centric. The former requires both a trained DNN and running data through that network; the latter requires only the trained network itself. One dataset-centric approach is to display images from the training or test set that cause high or low activations for individual units. Another is the deconvolution method of Zeiler & Fergus (2013), which highlights the portions of a particular image that are responsible for the firing of each neural unit.
Network-centric approaches investigate a network directly without any data from a dataset. For example, Erhan et al. (2009) synthesized images that cause high activations for particular units. Starting with some initial input \mathbf{x}=\mathbf{x_{0}}, the activation a_{i}(\mathbf{x}) caused at some unit i by this input is computed, and then steps are taken in input spacealong the gradient \partial a_{i}(\mathbf{x})/\partial\mathbf{x} to synthesize inputs that cause higher and higher activations of unit i, eventually terminating at some \mathbf{x^{*}} which is deemed to be a preferred input stimulus for the unit in question. In the case where the input space is an image, \mathbf{x^{*}} can be displayed directly for interpretation. Others have followed suit, using the gradient to find images that cause higher activations (Simonyan et al., 2013; Nguyen et al., 2014) or lower activations (Szegedy et al., 2013) for output units.","A network-centric approach requires only the trained network, while a dataset-centric approach requires both a trained DNN and running data through that network.",0.2156862714782776,0.0141843946280372,0.1960784283410226,1.4209774708876974,36.90817458331644,32.1690114325917,0.0710339384372533,0.0019290447035142,0.5535597801208496,0.7627749709305225,0.7453426718711853,0.6565082669258118,0.0635845853468808,0.2062937468290329,3,1.0,2.0,1.0,0.9556783135290386,0.3920897933593341,0.90169250677067,1.0,0.2062937468290329
16,16,"What is an example of a ""dataset-centric"" approach?","An example of ""dataset-centric"" approach can be deconvolution method which is used to highlight certain regions of some image that has the highest effects in the response of different units.","Another approach is to try to interpret the function computed by each individual neuron. Past studies in this vein roughly divide into two different camps: dataset-centric and network-centric. The former requires both a trained DNN and running data through that network; the latter requires only the trained network itself. One dataset-centric approach is to display images from the training or test set that cause high or low activations for individual units. Another is the deconvolution method of Zeiler & Fergus (2013), which highlights the portions of a particular image that are responsible for the firing of each neural unit.",Displaying images from the training or test set that cause high or low activations for individual units.,0.1395348790481342,0.0,0.0930232511411576,2.6711961764401657,28.171754869961447,24.16448809124605,0.1180952380952381,0.0060347887823926,0.4145295023918152,0.567873693333787,0.4145295023918152,0.5526729822158813,0.0139469316737171,0.2879064083099365,4,1.0,1.0,1.0,0.8668185577866206,0.7036947607526354,0.8147790430105416,1.0,0.2879064083099365
17,17,"What is an example of a ""network-centric"" approach?","An example of such approach would be to consider a trained network, start with some initial input and compute the forward path activations. compute gradients through backprop and then move this input towards or against the gradient direction until you have some interesting input that is of much significance in the responses of considered neurons.","Network-centric approaches investigate a network directly without any data from a dataset. For example, Erhan et al. (2009) synthesized images that cause high activations for particular units. Starting with some initial input \mathbf{x}=\mathbf{x_{0}}, the activation a_{i}(\mathbf{x}) caused at some unit i by this input is computed, and then steps are taken in input spacealong the gradient \partial a_{i}(\mathbf{x})/\partial\mathbf{x} to synthesize inputs that cause higher and higher activations of unit i, eventually terminating at some \mathbf{x^{*}} which is deemed to be a preferred input stimulus for the unit in question. In the case where the input space is an image, \mathbf{x^{*}} can be displayed directly for interpretation. Others have followed suit, using the gradient to find images that cause higher activations (Simonyan et al., 2013; Nguyen et al., 2014) or lower activations (Szegedy et al., 2013) for output units.",The answer is Erhan et al. (2009).,0.037735846763973,0.0,0.037735846763973,0.8237054296530683,6.601921110716175,7.022198447131143,0.0375234521575984,0.0013190126248351,0.0688781067728996,0.2376545562520382,0.0930523090064525,0.2115119844675064,0.0106450505029596,0.0562693551182746,1,1.0,0.0,1.0,0.7476262733363491,0.7804122026824155,0.7216488107296617,0.8,0.0562693551182746
18,18,"What is meant by ""hacks""?",'Hacks' means that they are not likely to naturally exist (non-natural looking images). However they may even cause harmful changes in the response of the network. Adversarial points for instance are examples of such hacks where slight increments in pixels of even correctly classified images can make them fool the network and tend to go beyond there original part of space and hence be misclassified.,"These gradient-based approaches are attractive in their simplicity, but the optimization process tends to produce images that do not greatly resemble natural images. Instead, they are composed of a collection of “hacks” that happen to cause high (or low) activations: extreme pixel values, structured high frequency patterns, and copies of common motifs without global structure (Simonyan et al., 2013; Nguyen et al., 2014; Szegedy et al., 2013; Goodfellow et al., 2014). The fact that activations may be effected by such hacks is better understood thanks to several recent studies. Specifically, it has been shown that such hacks may be applied to correctly classified images to cause them to be misclassified even via imperceptibly small changes (Szegedy et al., 2013), that such hacks can be found even without the gradient information to produce unrecognizable “fooling examples” (Nguyen et al., 2014), and that the abundance of non-natural looking images that cause extreme activations can be explained by the locally linear behavior of neural nets(Goodfellow et al., 2014).","Extreme pixel values, structured high frequency patterns, and copies of common motifs without global structure.",0.0588235259731836,0.0,0.0588235259731836,0.679364123713465,18.44001091571389,15.153770034196008,0.030441400304414,0.002375296912114,0.2667140662670135,0.5393021241540001,0.2893761396408081,0.0397327579557895,0.003252041803031,0.0520334467291832,4,1.0,1.0,1.0,0.7249800222030592,0.1952356260090168,0.7809425040360672,1.0,0.0520334467291832
19,19,"The paper's pre-trained network is nearly identical to the “AlexNet”. Does it use the same training set as the ""AlexNet""?","Yes both were trained on ImageNet 2012 dataset but paper's network first subtracted the per-pixel mean of examples in ImageNet before inputting training examples to the network. Hence, direct input to the network, x, can be thought of as a zero-centered input.","Both of our tools are released as open source and are available athttp://yosinski.com/deepvis. While the tools could be adapted to integrate with any DNN software framework, they work out of the box withthe popular Caffe DNN software package (Jia et al., 2014).Users may run visualizations with their own Caffe DNN or our pre-trained DNN, which comes with pre-computed images optimized to activate each neuron in this trained network. Our pre-trained network is nearly identical to the “AlexNet” architecture (Krizhevsky et al., 2012), but with local reponse normalization layers after pooling layers following (Jia et al., 2014). It was trained with the Caffe framework on the ImageNet 2012 dataset (Deng et al., 2009).
Our network was trained on ImageNet by first subtracting the per-pixel mean of examples in ImageNet before inputting training examples to the network. Thus, the direct input to the network, \mathbf{x}, can be thought of as a zero-centered input. We may pose the optimization problem as finding an image \mathbf{x^{*}} where",No.,0.0,0.0,0.0,0.7772751558853214,2.1645021645021645,3.199146894161557,0.0115207373271889,0.000238038562247,0.1322141736745834,0.2274197041988372,0.1253448724746704,,0.0076264597317887,0.0554165691137313,1,0.0,0.0,0.5,0.7675140161114538,0.4813788062497357,0.7255152249989427,1.0,0.0554165691137313
20,20,"What is meant by ""row-major"" order?","""row-major"" means that consecutive small grayscale images of each row reside next to each other unlike ""column-major"" and both are methods of storing elements in memory.","Figure 1 shows examples of this type of plot for the \mathsf{conv5} layer.The \mathsf{conv5} layer has size 256\times13\times13, which we depict as 256 separate 13\times13 grayscale images. Each of the 256 small images contains activations in the same spatial x-y spatial layout as the input data, and the 256 images are simply and arbitrarily tiled into a 16\times16 grid in row-major order.Figure 2 shows a zoomed in view of one particular channel, \mathsf{conv5_{151}}, that responds to human and animal faces. All layers can be viewed in the software tool, including pooling and normalization layers. Visualizing these layers provides intuitions about their effects and functions.",Organizing elements in rows before columns.,0.1333333301333334,0.066666663888889,0.1333333301333334,2.6545937801413144,31.62362928082198,28.21913704717447,0.1103583916083916,0.0023942537909018,0.431869626045227,0.7016735615125343,0.4318695962429046,0.5955304503440857,0.0182481655903214,0.2255579531192779,4,0.6666666666666666,2.0,1.0,0.7808175488223439,0.5809493461150934,0.8237973844603739,0.9,0.2255579531192779
21,21,"Why was a zero-centered input used for training the paper's DNN, instead of using the training images as input directly?","Zero mean input data and Standardization in general improve the convergence properties of BP training, so it can help to reach desired solution fast. Also, Authors may intend to have centered inputs so that network reduces its biasing towards certain classes or certain large or tiny response values, hence we can have reasonable values for activations and more visualizable responses from different neurons.","Our network was trained on ImageNet by first subtracting the per-pixel mean of examples in ImageNet before inputting training examples to the network. Thus, the direct input to the network, \mathbf{x}, can be thought of as a zero-centered input. We may pose the optimization problem as finding an image \mathbf{x^{*}} where",To reduce the effect of pixel intensity variations.,0.0624999978125,0.0,0.0624999978125,0.6998018210509476,17.602797014233985,15.006440919383804,0.0402576489533011,0.0013097576948264,0.1610991805791854,0.5321043536943547,0.2868177890777588,0.3119744658470154,0.0071190050957983,0.0423176176846027,4,1.0,1.0,,0.8521658814747438,0.4978913298679876,0.7915653194719503,0.8,0.0423176176846027
22,22,"For the paper's pretrained DNN, if the input does not contain a training set class, why does the probability vector show sensitivity towards the noise in input?","The reason is that convolution layers learn parameters that can extract useful information and relations from the feature map that can help it afterwards to judge and give suitable responses of what this category is. Responses from learned detectors can resemble among some set of categories and can also differ among other set of categories. Input -not being in the training classes- still has a feature map that different layers would respond to according to those different detectors which the network has already learned and would still give a probability vector which may not be accurate. Hence, having noise in the input can stimulate different detectors to respond and fire different activations that would lead to changes in the probability output vector.","•One of the most interesting conclusions so far has been that representations on some layers seem to be surprisingly local. Instead of finding distributed representations on all layers, we see, for example, detectors for text, flowers, fruit, and faces on \mathsf{conv4} and \mathsf{conv5}. These conclusions can be drawn either from the live visualization or the optimized images (or, best, by using both in concert) and suggest several directions for future research (discussed in Section 4).•When using direct file input to classify photos from Flickr or Google Images, classifications are often correct and highly confident (softmax probability for correct class near 1). On the other hand, when using input from a webcam, predictions often cannot be correct because no items from the training set are shown in the image. The training set’s 1000 classes, though numerous, do not cover most common household objects. Thus, when shown a typical webcam view of a person with no ImageNet classes present, the output has no single high probability, as is expected. Surprisingly, however, this probability vector is noisy and varies significantly in response to tiny changes in the input, often changing merely in response to the noise from the webcam. We might have instead expected unchanging and low confidence predictions for a given scene when no object the network has been trained to classify is present. Plotting the fully connected layers (\mathsf{fc6} and \mathsf{fc7}) also reveals a similar sensitivity to small input changes.•Although the last three layers are sensitive to small input changes, much of the lower layer computation is more robust. For example, when visualizing the \mathsf{conv5} layer, one can find many invariant detectors for faces, shoulders, text, etc. by moving oneself or objects in front of the camera. Even though the 1000 classes contain no explicitly labeled faces or text, the network learns to identify these concepts simply because they represent useful partial information for making a later classification decision. One face detector, denoted \mathsf{conv5_{151}} (channel number 151 on \mathsf{conv5}), is shown in Figure 2 activating for human and lion faces and in Figure 1 activating for a cat face. Zhou et al. (2014) recently observed a similar effect where convnets trained only to recognize different scene types — playgrounds, restaurant patios, living rooms, etc. — learn object detectors (e.g. for chairs, books, and sofas) on intermediate layers.","Because lower layers learn invariant detectors for useful partial information, such as faces and text, which can activate in response to noise.",0.2083333298003472,0.0149253704912011,0.1666666631336806,0.8996774811626016,29.044019518608664,25.610769596875947,0.0684931506849314,0.0019093907307759,0.6450016498565674,0.7915418115570064,0.53055739402771,0.7036460041999817,0.0151665778389924,0.1871860772371292,4,1.0,2.0,1.0,0.7900392888932313,0.5185622839246111,0.8742491356984442,0.8,0.1871860772371292
23,23,"The paper wished to only show the main object , letting other regions be exactly zero if they are not needed. How did the authors achieve it?",The paper reaches this goal by calculating each pixel norm over the 3 colour channels and zeroing out small-norm pixels according to some threshold (the percentile of all pixel norms in x).,"Clipping pixels with small norm: The first two regularizations suppress high amplitude and high frequency information, so after applying both, we are left with an \mathbf{x^{*}} that contains somewhat small, somewhat smooth values. However, \mathbf{x^{*}} will still tend to contain non-zero pixel values everywhere. Even if some pixels in \mathbf{x^{*}} show the primary object or type of input causing the unit under consideration to activate, the gradient with respect to all other pixels in \mathbf{x^{*}} will still generally be non-zero, so these pixels will also shift to show some pattern as well, contributing in whatever small way they can to ultimately raise the chosen unit’s activation. We wish to bias the search away from such behavior and instead show only the main object, letting other regions be exactly zero if they are not needed. We implement this bias using an r_{\theta}(\mathbf{x}) that computes the norm of each pixel (over red, green, and blue channels) and then sets any pixels with small norm to zero. The threshold for the norm, \theta_{\mathrm{n\_pct}}, is specified as a percentile of all pixel norms in \mathbf{x}.",They implemented an r_{\theta}(\mathbf{x}) that sets pixels with small norm to zero.,0.1395348796971336,0.0,0.093023251790157,1.7176188460170134,23.5640475316408,20.457300700582817,0.1186943620178041,0.0039840637450199,0.6270411610603333,0.4653576624303324,0.6270410418510437,0.761967122554779,0.0081453701296728,0.1443933546543121,3,1.0,4.0,1.0,0.820287701421862,0.5138493439019499,0.8553911017795778,0.0,0.1443933546543121
24,24,How many hyperparameter combinations were used for the random hyperparameter search?,300 sets of possible hyperparameter combinations then choose four of them that complement each other well.,"If the above regularization methods are applied individually, they aresomewhat effective at producing more interpretable images; Figure 3 shows the effects of each individual hyperparameter.However, preliminary experiments uncovered that their combinedeffect produces better visualizations. To pick a reasonable set ofhyperparameters for all methods at once, we ran a randomhyperparameter search of 300 possible combinations and settled on fourthat complement each other well. The four selected combinations arelisted in Table 1 and optimized images using each are shown for the “Gorilla” class output unit in Figure 4. Of the four, some show highfrequency information, others low frequency; some contain densepixel data, and others contain only sparse outlines of importantregions.We found the version in the lower-left quadrant to be the best single set of hyperparameters, but often greater intuition canbe gleaned by considering all four at once.Figure 5 shows the optimization results computed for a selection of units on all layers. A single image for every filter of all five convolutional layers is shown in Supplementary Figure S1. Nine images for each filter of all layers, including each of the 1000 ImageNet output classes, can be viewed at http://yosinski.com/deepvis.",The answer is 300.,0.1052631545706372,0.0,0.1052631545706372,2.719665272174911,12.316197841159244,12.839392935011004,0.0632911392405063,0.0024937655860349,0.5020216107368469,0.212364686653018,0.5020215511322021,,0.0074343208771052,0.4079406261444092,4,1.0,4.0,,0.9716096419349,0.5718131035059676,0.7872524140238703,1.0,0.4079406261444092
25,25,The paper lists tools that enable understanding of neural networks for beginners. Have they mentioned the tools for expert users as well?,"They didn't mention specific tools for expert users. However, they have thoughts that even experts would benefit from their new ideas such as when experts iterate ideas for new models or while searching for good hyperparameters or maybe from intuitions about the inner workings of DNNs.","We also note that tools that enable understanding will especially benefit the vast numbers of newcomers to deep learning, who would like to take advantage of off-the-shelf software packages — like Theano (Bergstra et al., 2010), Pylearn2 (Goodfellow et al., 2013), Caffe (Jia et al., 2014), and Torch (Collobert et al., 2011) — in new domains, but who may not have any intuition for why their models work (or do not). Experts can also benefit as they iterate ideas for new models or when they are searching for good hyperparameters. We thus believe that both experts and newcomers will benefit from tools that provide intuitions about the inner workings of DNNs. This paper provides two such tools, both of which are open source so that scientists and practitioners can integrate them with their own DNNs to better understand them.",The answer is yes.,0.0,0.0,0.0,0.7445292335166879,6.974537126987601,6.1719290920428325,0.0219780219780219,0.0008880994671403,0.0870006531476974,0.3383274322388157,0.1175387874245643,,0.0485544941292692,0.0684608668088913,3,0.0,0.0,1.0,0.7631319589575685,0.6842182826560439,0.7368731306241756,1.0,0.0684608668088913
26,26,"The paper's model implies that the discriminative parameters also contain significant “generative” structure from the training dataset. What is meant by ""generative"" structure?","Generative structure is how the data is distributed inside the space where it lives, for example when learning to detect jaguar class, parameters encode not only the jaguar’s spots(Only to distinguish it through a rare property), but to some extent also its four legs(to learn the pattern with which the whole creature can be found). So, discriminative parameters also contain significant “generative” structure.","However, the results presented here suggest an alternate possibility: the previously used priors may simply have been too weak (see Section S1 for one hypothesis of why a strong p(x) model is needed). With the careful design or learning of a p(x) model that biases toward realism,one may be able to harnessthe large number of parameters present in a discriminately learned p(y|x) modelto generate realistic images by enforcing probability under both models simultaneously.Even with the simple, hand-coded p(x) models we use in this paper as regularizers, complex dependencies between distant pixels already arise (cf. the beetles with structure spanning over 100 pixels in Figure 4). This implies that the discriminative parameters also contain significant “generative” structure from thetraining dataset; that is, the parameters encodenot only the jaguar’s spots, but to some extent also its four legs.With better, learned probabilistic models over the input and activations of higher layers, much more structure may be apparent. Work by Dai et al. (2015) shows some interesting results in this direction.While the images generated in this paper are far from being photo-realistic, they do suggest thattransferring discriminatively trained parameters to generative models — opposite the direction of the usual unsupervised pretraining approach — may be a fruitful area for further investigation.",The model's ability to encode complex dependencies and relationships between pixels.,0.0634920606097255,0.0,0.0634920606097255,0.6331377889807558,17.11860342058347,14.454003640293635,0.0345303867403314,0.0018299783729828,0.4903130829334259,0.5395818852883524,0.519123375415802,0.4839704930782318,0.0131260673070022,0.0855902656912803,3,1.0,1.0,1.0,0.7657412330363041,0.4501435227640951,0.8005740910563804,0.8,0.0855902656912803
27,27,How does the performance change when a dense retriever is evaluated on out-of-domain queries and documents that are different from the domain on which the retriever was trained?,"It is said that when evaluating a retriever trained on a source domain in an out-of-domain setting, the performance is obtained lower than BM25. Also, dense retrievers are said to be sensitive to domain shift and models that perform well on MS MARCO do not perform well on COVID-19 data. There have been many studies on unsupervised sentence embedding learning, but it is said that they do not work well in unsupervised dense retrieval. Therefore, the performance of the retriever in out-of-domain may be worse.","However, as shown in Thakur et al. (2021b), dense retrieval methods require large amounts of training data to work well.333For reference, the popular MS MARCO dataset (Nguyen et al., 2016) has about 500k training instances; the Natural Questions dataset (Kwiatkowski et al., 2019) has more than 100k training instances.  Most importantly, dense retrieval methods are extremely sensitive to domain shifts: Models trained on MS MARCO perform rather poorly for questions for COVID-19 scientific literature (Wang et al., 2020; Voorhees et al., 2021). The MS MARCO dataset was created before COVID-19, hence, it does not include any COVID-19 related topics and models did not learn how to represent this topic well in a vector space.
We use the MS MARCO passage ranking dataset Nguyen et al. (2016) as the data from the source domain. It has 8.8M passages and 532.8K query-passage pairs labeled as relevant in the training set. As Table 1 shows, a state-of-the-art dense retrieval model, achieving an MRR@10 of 33.2 points on the MS MARCO passage ranking dataset, performs poorly on the six selected domain-specific retrieval datasets when compared to simple BM25 lexical search.
So far, ICT and CD have only been studied on in-domain performance, i.e. a large in-domain labeled dataset is available which is used for subsequent supervised fine-tuning. SimCSE, CT, and TSDAE have been only studied for unsupervised sentence embedding learning. As our results show in Appendix E, they do not work at all for purely unsupervised dense retrieval.
If these pre-training approaches can be used for unsupervised domain adaptation for dense retrieval was so far unclear. In this work, we transfer the setup from Wang et al. (2021) to dense retrieval and first pre-train on the target corpus, followed by supervised training on labeled data from MS MARCO Nguyen et al. (2016). Performance is then measured on the target corpus.",It performs poorly.,0.0327868843106692,0.0,0.0327868843106692,0.4595405460985375,7.534677671080399,6.801255928375939,0.0178359096313912,0.0003570153516601,0.2436639070510864,0.407187017025771,0.3020170629024505,,0.002804151873542,0.1272609233856201,3,1.0,2.0,,0.0,0.4068655632580381,0.7703193958892953,0.8,0.1272609233856201
28,28,"What kinds of relevant documents are missing, when lexical matching is used for retrieval?",Using lexical matching makes it difficult to identify synonyms or to distinguish between ambiguous words.,"Information Retrieval (IR) is a central component of many natural language applications. Traditionally, lexical methods (Robertson et al., 1994) have been used to search through text content. However, these methods suffer from the lexical gap (Berger et al., 2000) and are not able to recognize synonyms and distinguish between ambiguous words.",Documents containing synonyms or ambiguous words.,0.3999999958,0.2105263119113573,0.3999999958,11.44707843033496,47.29142155935226,47.40937640385003,0.3205298013245032,0.0054249547920434,0.6776089072227478,0.8145776187831706,0.6776089668273926,0.665091872215271,0.0641690100840537,0.1690258681774139,4,0.3333333333333333,4.0,1.0,0.8800011034266723,0.7151615693801461,0.8606462775205841,0.9,0.1690258681774139
29,29,What are the factors that should be considered for memory footprint for indexing?,"During indexing, we use another server with the same CPU and system memory specifications but which has four Titan V GPUs attached, each with 12 GiBs of memory. Across all experiments, only one GPU is dedicated per query for retrieval (i.e., for methods with neural computations) but we use up to all four GPUs during indexing.","To evaluate the latency of neural re-ranking models in §4.2, we use a single Tesla V100 GPU that has 32 GiBs of memory on a server with two Intel Xeon Gold 6132 CPUs, each with 14 physical cores (24 hyperthreads), and 469 GiBs of RAM. For the mostly CPU-based retrieval experiments in §4.3 and the indexing experiments in §4.5, we use another server with the same CPU and system memory specifications but which has four Titan V GPUs attached, each with 12 GiBs of memory. Across all experiments, only one GPU is dedicated per query for retrieval (i.e., for methods with neural computations) but we use up to all four GPUs during indexing.","GPU memory, system memory.",0.115384613964497,0.0338983041195059,0.115384613964497,1.6898369320139537,21.445185672309915,21.9456854532951,0.0515463917525773,0.000740192450037,0.5597690343856812,1.0,0.5979914665222168,0.7374000549316406,0.0040913281460253,0.2170458287000656,3,1.0,1.0,1.0,0.8067135442632832,0.2023556966862484,0.8094227867449939,0.8,0.2170458287000656
30,30,"What are pros and cons of these models illustrated in Figure 2, and what are distinctions of the proposed model?  ","Using figure 2, 
These increasingly expressive architectures are in tension. While interaction-based models (i.e., Figure 2 (b) and (c)) tend to be superior for IR tasks (Guo et al., 2019; Mitraet al., 2018), a representation-focused model—by isolating the computations among q and d—makes it possible to pre-compute document representations offline (Zamani et al., 2018), greatly reducing the computational load per query. In this work, we observe that the fine-grained matching of interaction-based models and the pre-computation of document representations of representation-based models can be combined by retaining yet judiciously delaying the query–document interaction. Figure 2 (d) illustrates an architecture that precisely does so. As illustrated, every query embedding interacts with all document embeddings via a MaxSim operator, which computes maximum similarity (e.g., cosine similarity), and the scalar outputs of these operators are summed across query terms. This paradigm allows ColBERT to exploit deep LM-based representations while shifting the cost of encoding documents offline and amortizing the cost of encoding the query once across all ranked documents. Additionally, it enables ColBERT to leverage vector-similarity search indexes (e.g., (Johnsonet al., 2017; Abuzaidet al., 2019)) to retrieve the top-k results directly from a large document collection, substantially improving recall over models that only re-rank the output of term-based retrieval.






The distinction of proposed model : 1) a highly-effective model is proposed that employs novel BERT-based query and document encoders within the late interaction paradigm.(2) We show how to leverage ColBERT both for re-ranking on top of a term-based retrieval model (3) and for searching a full collection using vector similarity indexes.(4)We evaluate ColBERT on MS MARCO and TREC CAR, two recent passage search collections.","These increasingly expressive architectures are in tension. While interaction-based models (i.e., Figure 2 (b) and (c)) tend to be superior for IR tasks (Guo et al., 2019; Mitraet al., 2018), a representation-focused model—by isolating the computations among q and d—makes it possible to pre-compute document representations offline (Zamani et al., 2018), greatly reducing the computational load per query. In this work, we observe that the fine-grained matching of interaction-based models and the pre-computation of document representations of representation-based models can be combined by retaining yet judiciously delaying the query–document interaction. Figure 2 (d) illustrates an architecture that precisely does so. As illustrated, every query embedding interacts with all document embeddings via a MaxSim operator, which computes maximum similarity (e.g., cosine similarity), and the scalar outputs of these operators are summed across query terms. This paradigm allows ColBERT to exploit deep LM-based representations while shifting the cost of encoding documents offline and amortizing the cost of encoding the query once across all ranked documents. Additionally, it enables ColBERT to leverage vector-similarity search indexes (e.g., (Johnsonet al., 2017; Abuzaidet al., 2019)) to retrieve the top-k results directly from a large document collection, substantially improving recall over models that only re-rank the output of term-based retrieval.
Our main contributions are as follows.(1)We propose late interaction (§3.1) as a paradigm for efficient and effective neural ranking.(2)We present ColBERT (§3.2 & 3.3), a highly-effective model that employs novel BERT-based query and document encoders within the late interaction paradigm.(3)We show how to leverage ColBERT both for re-ranking on top of a term-based retrieval model (§3.5) and for searching a full collection using vector similarity indexes (§3.6).(4)We evaluate ColBERT on MS MARCO and TREC CAR, two recent passage search collections.","**Figure 2 (a) and (b) models:**
Pros: Superior for IR tasks.
Cons: High computational load per query.

**Figure 2 (c) model:**
Pros: None mentioned.
Cons: None mentioned.

**Figure 2 (d) model (ColBERT):**
Pros: 
- Exploits deep LM-based representations.
- Shifts document encoding cost offline.
- Amortizes query encoding cost across ranked documents.
- Leverages vector-similarity search indexes for efficient retrieval.
- Improves recall over term-based retrieval models.

Cons: None mentioned.

**Distinctions of the proposed model (ColBERT):**
- Combines fine-grained matching and pre-computation of document representations.
- Retains query-document interaction, but judiciously delays it.
- Employs novel BERT-based query and document encoders.
- Can be used for re-ranking and full collection search.",0.3435114463283025,0.1362397780026581,0.3435114463283025,8.333694566070697,53.1979789043581,47.62161265942348,0.2587809586776858,0.0047011985938757,0.755142331123352,0.8002139425637239,0.578733891248703,0.6570371389389038,0.0409215261401144,,4,0.4,4.0,0.75,0.8947989056020548,0.8690749401577149,0.9048711892022886,0.95,
31,31,"What if a query term can be matched to multiple document terms? Does MaxSim suffice for capturing query-document relevance, for this case too?","if a query term can be matched to multiple document terms, MaxSim suffice for capturing query-document relevance.  ColBERT computes the relevance score between q and d via late interaction, which we define as a summation of maximum similarity (MaxSim) operators. In particular, we find the maximum cosine similarity of each v\in E_{q} with vectors in E_{d}, and combine the outputs via summation.","Using E_{q} and E_{d}, ColBERT computes the relevance score between q and d via late interaction, which we define as a summation of maximum similarity (MaxSim) operators. In particular, we find the maximum cosine similarity of each v\in E_{q} with vectors in E_{d}, and combine the outputs via summation. Besides cosine, we also evaluate squared L2 distance as a measure of vector similarity. Intuitively, this interaction mechanism softly searches for each query term t_{q}—in a manner that reflects its context in the query—against the document’s embeddings, quantifying the strength of the “match” via the largest similarity score between t_{q} and a document term t_{d}. Given these term scores, it then estimates the document relevance by summing the matching evidence across all query terms.
Given the representation of a query q and a document d, the relevance score of d to q, denoted as S_{q,d}, is estimated via late interaction between their bags of contextualized embeddings. As mentioned before, this is conducted as a sum of maximum similarity computations, namely cosine similarity (implemented as dot-products due to the embedding normalization) or squared L2 distance.",No.,0.0,0.0,0.0,0.4447652331523465,0.9633911368015416,1.8780083642389327,0.0071942446043165,0.0001612643122077,0.0240750070661306,0.3159438073635101,0.0395797602832317,,0.0025804335302303,0.0515819862484931,1,0.0,0.0,1.0,0.0,0.47281321304653,0.6912528521861198,0.0,0.0515819862484931
32,32,What are the metrics they used for measuring efficiency and effectiveness?,They used (MRR@10) for measuring efficiency and effectiveness .,"Diving deeper into the quality–cost tradeoff between BERT and ColBERT, Figure 4 demonstrates the relationships between FLOPs and effectiveness (MRR@10) as a function of the re-ranking depth k when re-ranking the top-k results by BM25, comparing ColBERT and BERT{}_{\textnormal{base}} (our training). We conduct this experiment on MS MARCO (Dev). We note here that as the official top-1000 ranking does not provide the BM25 order (and also lacks documents beyond the top-1000 per query), the models in this experiment re-rank the Anserini (Yanget al., 2018) toolkit’s BM25 output. Consequently, both MRR@10 values at k=1000 are slightly higher from those reported in Table 1.",FLOPs and MRR@10.,0.1818181778512397,0.0,0.1818181778512397,13.065113298388567,22.464750533712863,21.858359140339125,0.3626016260162602,0.0037359900373599,0.3787101805210113,0.4981554627418517,0.3787101507186889,,0.0113059173893006,0.7518272399902344,4,1.0,4.0,1.0,0.9238845191768572,0.7107157195914721,0.8428628783658881,0.8,0.7518272399902344
33,33,"What are the different aspects that MRR@10 and Recall@50/200/1000 capture, as evaluation metrics for end-to-end retrieval performance ?","In fact, using ColBERT in the end-to-end setup is superior in terms of MRR@10 to re-ranking with the same model due to the improved recall. Moving beyond MRR@10, large gains in Recall@k for k equals to 50, 200, and 1000. For instance, its Recall@50 actually exceeds the official BM25’s Recall@1000 and even all but docTTTTTquery’s Recall@200, emphasizing the value of end-to-end retrieval (instead of just re-ranking) with ColBERT.","Shifting our attention to ColBERT’s end-to-end retrieval effectiveness, we see its major gains in MRR@10 over all of these end-to-end models. In fact, using ColBERT in the end-to-end setup is superior in terms of MRR@10 to re-ranking with the same model due to the improved recall. Moving beyond MRR@10, we also see large gains in Recall@k for k equals to 50, 200, and 1000. For instance, its Recall@50 actually exceeds the official BM25’s Recall@1000 and even all but docTTTTTquery’s Recall@200, emphasizing the value of end-to-end retrieval (instead of just re-ranking) with ColBERT.","MRR@10 captures early ranking performance, while Recall@50/200/1000 captures overall retrieval effectiveness and recall at different depths.",0.1159420255828608,0.0,0.086956518336484,3.00062477515122,29.63701134299862,24.80134012147317,0.057012542759407,0.0024183796856106,0.6270617842674255,0.6350177147828822,0.7085806131362915,0.4723043441772461,0.0214660921354157,0.1501393020153045,4,1.0,3.0,1.0,0.8750165683591274,0.5959465516856921,0.8837862067427683,0.8,0.1501393020153045
34,34,"If both queries and documents are short, is still the fine-granular interaction required?","During indexing, we use another server with the same CPU and system memory specifications but which has four Titan V GPUs attached, each with 12 GiBs of memory. Across all experiments, only one GPU is dedicated per query for retrieval (i.e., for methods with neural computations) but we use up to all four GPUs during indexing.","These increasingly expressive architectures are in tension. While interaction-based models (i.e., Figure 2 (b) and (c)) tend to be superior for IR tasks (Guo et al., 2019; Mitraet al., 2018), a representation-focused model—by isolating the computations among q and d—makes it possible to pre-compute document representations offline (Zamani et al., 2018), greatly reducing the computational load per query. In this work, we observe that the fine-grained matching of interaction-based models and the pre-computation of document representations of representation-based models can be combined by retaining yet judiciously delaying the query–document interaction. Figure 2 (d) illustrates an architecture that precisely does so. As illustrated, every query embedding interacts with all document embeddings via a MaxSim operator, which computes maximum similarity (e.g., cosine similarity), and the scalar outputs of these operators are summed across query terms. This paradigm allows ColBERT to exploit deep LM-based representations while shifting the cost of encoding documents offline and amortizing the cost of encoding the query once across all ranked documents. Additionally, it enables ColBERT to leverage vector-similarity search indexes (e.g., (Johnsonet al., 2017; Abuzaidet al., 2019)) to retrieve the top-k results directly from a large document collection, substantially improving recall over models that only re-rank the output of term-based retrieval.",No.,0.0,0.0,0.0,0.5398548275054964,1.1737089201877933,2.151284902396837,0.0086505190311418,0.0001785395465095,0.087326094508171,0.2622675001621246,0.0885253548622131,,0.002383594897733,0.0696660801768302,1,0.0,0.0,1.0,0.0,0.1786096813425863,0.7144387253703453,0.0,0.0696660801768302
35,35,"Targeting memory-efficient indexing, can we also prune out redundant tokens in documents while preserving a sufficient level of fine granularity?","Targeting memory-efficient indexing, tokens are not appended in documents. We first segment a document d into its constituent tokens d_{1}d_{2}...d_{m}, to which we prepend BERT’s start token [CLS] followed by our special token [D] that indicates a document sequence. Unlike queries, we do not append [mask] tokens to documents. After passing this input sequence through BERT and the subsequent linear layer, the document encoder filters out the embeddings corresponding to punctuation symbols, determined via a pre-defined list. This filtering is meant to reduce the number of embeddings per document, as we hypothesize that (even contextualized) embeddings of punctuation are unnecessary for effectiveness.","Document Encoder. Our document encoder has a very similar architecture. We first segment a document d into its constituent tokens d_{1}d_{2}...d_{m}, to which we prepend BERT’s start token [CLS] followed by our special token [D] that indicates a document sequence. Unlike queries, we do not append [mask] tokens to documents. After passing this input sequence through BERT and the subsequent linear layer, the document encoder filters out the embeddings corresponding to punctuation symbols, determined via a pre-defined list. This filtering is meant to reduce the number of embeddings per document, as we hypothesize that (even contextualized) embeddings of punctuation are unnecessary for effectiveness. ","Yes, we can also prune out redundant tokens.",0.0689655155714097,0.0,0.0689655155714097,0.6514062508817897,10.910622386715266,10.605940837680905,0.0204081632653061,0.0007993605115907,0.3977107405662536,0.6060172210892906,0.5407582521438599,0.5098357200622559,0.0158823531046443,0.0429065935313701,3,1.0,1.0,0.5,0.9001427404304788,0.3838443681638295,0.7853774726553182,0.7,0.0429065935313701
36,36,"How much does the late interaction decrease computational costs, and how close is the performance of the late interaction model to the early interaction model?","In contrast with this trend, ColBERT (which employs late interaction over BERT performs no worse than the original adaptation of BERT for ranking and is only marginally less effective than BERT and our training of BERT. While highly competitive in effectiveness, ColBERT is orders of magnitude cheaper than BERT, in particular, by over 170\times in latency and 13,900\times in FLOPs.","In contrast with this trend, ColBERT (which employs late interaction over BERT{}_{\textnormal{base}}) performs no worse than the original adaptation of BERT{}_{\textnormal{base}} for ranking by Nogueira and Cho (Nogueira and Cho, 2019; Nogueiraet al., 2019b) and is only marginally less effective than BERT{}_{\textnormal{large}} and our training of BERT{}_{\textnormal{base}} (described above). While highly competitive in effectiveness, ColBERT is orders of magnitude cheaper than BERT{}_{\textnormal{base}}, in particular, by over 170\times in latency and 13,900\times in FLOPs. This highlights the expressiveness of our proposed late interaction mechanism, particularly when coupled with a powerful pre-trained LM like BERT. While ColBERT’s re-ranking latency is slightly higher than the non-BERT re-ranking models shown (i.e., by 10s of milliseconds), this difference is explained by the time it takes to gather, stack, and transfer the document embeddings to the GPU. In particular, the query encoding and interaction in ColBERT consume only 13 milliseconds of its total execution time. We note that ColBERT’s latency and FLOPs can be considerably reduced by padding queries to a shorter length, using smaller vector dimensions (the MRR@10 of which is tested in §4.5), employing quantization of the document vectors, and storing the embeddings on GPU if sufficient memory exists. We leave these directions for future work.","- Computational costs decrease by over 170 times in latency and 13,900 times in FLOPs.
- Performance of the late interaction model is marginally less effective than the early interaction model.",0.4285714239795918,0.2093023211898324,0.3714285668367347,14.338264105305775,51.75706482588317,47.69351937164707,0.2508972281747069,0.0062867572500506,0.4202989637851715,0.6163430226536898,0.417287990450859,0.692201554775238,0.0675981913624292,0.2597801983356476,4,1.0,5.0,0.5,0.8752204096782288,0.714664214298372,0.858656857193488,0.0,0.2597801983356476
37,37,What kinds of distribution shifts are considered for evaluating retrievers on out-of-distribution datasets?,"BioASQ, or task-shifts like in Touché-2020 distribution shifts are considered for evaluating retrievers on out-of-distribution datasets","3. Dense retrieval models with issues for out-of-distribution data. Dense retrieval models (esp. ANCE and TAS-B), that map queries and documents independently to vector spaces, perform strongly on certain datasets, while on many other datasets perform significantly worse than BM25. For example, dense retrievers are observed to underperform on datasets with a large domain shift compared from what they have been trained on, like in BioASQ, or task-shifts like in Touché-2020. DPR, the only non-MSMARCO trained dataset overall performs the worst in generalization on the benchmark.",Domain shift and task-shift.,0.0,0.0,0.0,0.0,29.671768081543416,22.253826061157568,0.0632911392405063,0.0024937655860349,0.3980914056301117,0.346193063749026,0.3980914354324341,0.3906429409980774,0.0123980525178426,0.0726069584488868,4,1.0,4.0,1.0,0.8518750661515684,0.5881151646374607,0.8524606585498431,0.8,0.0726069584488868
38,38,Does a zero-shot scenario in this context refer to cases where relevance annotations are not available? Or are you referring to the case where the query set is also unavailable?,"creating a large training corpus is often time-consuming and expensive and hence many retrieval systems are applied in a zero-shot setup, with no available training data to train the system. Hence, a zero-shot scenario in this context refer to cases where relevance annotations are not available and  does not refer to unavailability of query set.","However, creating a large training corpus is often time-consuming and expensive and hence many retrieval systems are applied in a zero-shot setup, with no available training data to train the system. So far, it is unclear how well existing trained neural models will perform for other text domains or textual retrieval tasks. Even more important, it is unclear how well different approaches, like sparse embeddings vs. dense embeddings, generalize to out-of-distribution data.",The answer is the former.,0.0851063810774106,0.0,0.0851063810774106,0.8093746504746996,8.258343552594058,8.493940326380239,0.0279329608938547,0.000942507068803,0.0307272672653198,0.3779934136183944,0.0713989585638046,,0.0174624684907613,0.0565287284553051,3,0.0,4.0,1.0,0.0,0.675429092930299,0.7017163717211957,0.5,0.0565287284553051
39,39,"If dense/sparse retrievers are pre-trained on target corpus to enable the retrievers to be corpus-aware, can the fine-tuned retrievers outperform lexical models?","If dense/sparse retrievers are pre-trained on target corpus to enable the retrievers to be corpus-aware, the fine-tuned retrievers underperform lexical models","We use beir to evaluate ten diverse retrieval methods from five broad architectures: lexical, sparse, dense, late interaction, and re-ranking. From our analysis, we find that no single approach consistently outperforms other approaches on all datasets. Further, we notice that the in-domain performance of a model does not correlate well with its generalization capabilities: models fine-tuned with identical training data might generalize differently. In terms of efficiency, we find a trade-off between the performances and the computational cost: computationally expensive models, like re-ranking models and late interaction model perform the best. More efficient approaches e.g. based on dense or sparse embeddings can substantially underperform traditional lexical models like BM25. Overall, BM25 remains a strong baseline for zero-shot text retrieval.",No.,0.0,0.0,0.0,0.0,1.111111111111111,0.6666666666666666,0.0,0.0004759638267491,0.0769634172320365,0.115181878209114,0.0769634172320365,,0.0019988624021521,0.0421189665794372,1,0.0,0.0,,0.0,0.6827302515241815,0.7307393080104019,0.75,0.0421189665794372
40,40,"How is the ""relevance"" defined in TREC-COVID dataset? ","relevance"" is defined as judgements in TREC-COVID dataset","Finally, we notice that there can be a strong lexical bias present in datasets included within the benchmark, likely as lexical models are pre-dominantly used during the annotation or creation of datasets. This can give an unfair disadvantage to non-lexical approaches. We analyze this for the TREC-COVID Voorhees et al. (2021) dataset: We manually annotate the missing relevance judgements for the tested systems and see a significant performance improvement for non-lexical approaches. Hence, future work requires better unbiased datasets that allow a fair comparison for all types of retrieval systems.",Manually annotated by the authors.,0.0,0.0,0.0,0.0,10.353598773583116,7.765199080187339,0.0,0.0062111801242236,0.2514859139919281,0.41394737133613,0.2514858841896057,0.2380250990390777,0.0099673607870243,0.0613382421433925,1,0.5,1.0,,0.8032456772671893,0.6859567284426771,0.7438269137707085,0.0,0.0613382421433925
41,41,"What does ""speed"" mean in retrieval contexts? ",Index are important as speed in retrieval system.,"Models need to potentially compare a single query against millions of documents at inference, hence, a high computational speed for retrieving results in real-time is desired. Besides speed, index sizes are vital and are often stored entirely in memory. We randomly sample 1 million documents from DBPedia Hasibi et al. (2017) and evaluate latency. For dense models, we use exact search, while for ColBERT we follow the original setup Khattab and Zaharia (2020) and use approximate nearest neighbor search. Performances on CPU were measured with an 8 core Intel Xeon Platinum 8168 CPU @ 2.70GHz and on GPU using a single Nvidia Tesla V100, CUDA 11.0.",Computational efficiency or processing speed.,0.1538461491124262,0.0,0.1538461491124262,5.669791110976001,18.48353186125341,17.72436190066589,0.1149425287356322,0.0062111801242236,0.413324236869812,0.6269286351819192,0.4133241474628448,0.6210223436355591,0.0068293646835839,0.0668413117527961,3,1.0,2.0,0.5,0.7998783463213238,0.583137984139992,0.8325519365599678,0.9,0.0668413117527961
42,42,What are examples where we have annotation holes?,"Lexical approaches like BM25 and docT5query have a rather low Hole@10 value of 6.4% and 2.8%, indicating that the annotation pool contained the top-hits from lexical retrieval systems. In contrast, dense retrieval systems like ANCE and TAS-B have a much higher Hole@10 of 14.4% and 31.8%, indicating that a large fraction of hits found by these systems have not been judged by annotators","The results reveal large differences between approaches: Lexical approaches like BM25 and docT5query have a rather low Hole@10 value of 6.4% and 2.8%, indicating that the annotation pool contained the top-hits from lexical retrieval systems. In contrast, dense retrieval systems like ANCE and TAS-B have a much higher Hole@10 of 14.4% and 31.8%, indicating that a large fraction of hits found by these systems have not been judged by annotators.Next, we manually added for all systems, the missing annotation (or holes) following the original annotation guidelines. During annotation, we were unaware of the system who retrieved the missing annotation to avoid a preference bias. In total, we annotated 980 query-document pairs in TREC-COVID. We then re-computed nDCG@10 for all systems with this additional annotations.",Query-document pairs retrieved by dense retrieval systems like ANCE and TAS-B.,0.2758620658917955,0.1690140820868875,0.2758620658917955,7.800435568808961,39.36713686325554,37.74025679188801,0.108296943231441,0.0019261075118192,0.6339384913444519,0.711436110999315,0.5928295850753784,0.6243506669998169,0.0479097534411334,0.2054553776979446,3,1.0,2.0,,0.7469839558298884,0.21477140719795,0.8590856287918001,0.8,0.2054553776979446
43,43,What are the motivation behind choosing TREC-COVID for analysis on annotation bias?,This dataset could be made unbiased by manual annotations,"Finally, we notice that there can be a strong lexical bias present in datasets included within the benchmark, likely as lexical models are pre-dominantly used during the annotation or creation of datasets. This can give an unfair disadvantage to non-lexical approaches. We analyze this for the TREC-COVID Voorhees et al. (2021) dataset: We manually annotate the missing relevance judgements for the tested systems and see a significant performance improvement for non-lexical approaches. Hence, future work requires better unbiased datasets that allow a fair comparison for all types of retrieval systems.",To analyze lexical bias in a real-world dataset.,0.1176470538408306,0.0,0.1176470538408306,4.767707020457095,24.095986081752315,19.46850401358677,0.0555555555555555,0.0088105726872246,0.4878919422626495,0.4891891382836008,0.4878919124603271,0.5117653012275696,0.0143240303559523,0.1805801391601562,1,0.5,1.0,0.0,0.8359785402982327,0.7076623083090887,0.8317311712953412,0.0,0.1805801391601562
44,44,Did the authors have an experiment showing the self-supervised learning can mitigate data sparsity issue?,"No, they do not.","Sequential recommendation aimsto accurately characterize users’ dynamic interestsby modeling their past behavior sequences (Rendle, 2010; Rendle et al., 2010; Kang and McAuley, 2018; Chen et al., 2021; Liet al., 2021a; Liuet al., 2021a).Early works on SR usually modelanitem-to-item transaction patternbased on MarkovChains (Rendle, 2010; He and McAuley, 2016).FPMC (Rendle et al., 2010)combines the advantages of Markov Chainsand matrix factorizationto fuse both sequential patternsand users’ general interest.With the recent advances of deep learning,many deep sequential recommendation modelsare also developed (Tang and Wang, 2018; Hidasi et al., 2015; Kang and McAuley, 2018; Sunet al., 2019). Such as Convolutional Neural Networks (CNN)-based (Tang and Wang, 2018) andRNN-based (Hidasi et al., 2015) models.The recent success of Transformer (Vaswani et al., 2017)also motivatesthe developments of pure Transformer-based SR models.SASRec (Kang and McAuley, 2018)utilizes unidirectional Transformerto assign weights to each interacted item adaptively.BERT4Rec (Sunet al., 2019) improves that byutilizing a bidirectional Transformerwith a Cloze task (Taylor, 1953)to fuse user behaviors information fromleft and right directions into each item.LSAN (Liet al., 2021a) improves SASRecon reducing model size perspective.It proposes a temporal context-aware embeddingand twin-attention network, which are light weighted.ASReP (Liuet al., 2021b) further alleviatesthe data-sparsity issueby leveraging a pre-trained Transformeron the revised user behavior sequences toaugment short sequences.In this paper, we study thepotential of addressing data sparsity issuesand improving SR via self-supervised learning.",No.,0.0,0.0,0.0,9.652434877402245,28.48837209302325,31.80100755667506,0.1785714285714285,0.0024937655860349,0.2436814159154892,1.0,0.2436814308166504,,0.0555324182176702,0.9562115669250488,4,0.0,5.0,,0.0,0.9703459973284424,0.8813839893137702,0.0,0.9562115669250488
45,45,Does the paper show that the learnt user intents by clustering are orthogonal to the sequence embeddings?,"No, it does not.","Effectively modeling latent intentsfrom user behaviorsposes two challenges.First,it is extremely difficult to learn latent intents accuratelybecause we have no labelling data for intents.The only available supervision signals for intents are the user behavior data. Nevertheless, as aforementioned example indicates, distinct behaviors may reflect the same intent.Besides,effectively fusing intent informationinto a SR model is non-trivial.The target in SR is to predict next items in sequences, which is solved by encoding sequences.Leveraging latent intents of sequences into the model requires the intentfactors to be orthogonal to the sequence embeddings,which otherwise would induce redundant information.
To discover the benefits oflatent intentsand address challenges,we propose theIntent Contrastive Learning (ICL),a general learning paradigm thatleverages the latent intentfactor into SR.It learns users’ intentdistributionsfrom all user behavior sequencesvia clustering.And it leveragesthe learnt intentsinto the SR modelvia a new contrastive SSL,whichmaximizes the agreementbetween a view of sequenceand its corresponding intent.The intent representation learning moduleand the contrastive SSL module are mutually reinforcedto train a more expressivesequence encoder.We tackle the challenge of intentmining problem byintroducing alatent variable to represent users’ intentsand learn them alternatelyalong with the SR model optimization throughan expectation-maximization (EM) frameworkto ensure convergence.We suggest fusing learnt intent informationinto SR via the proposed contrastive SSL,as it can improve model’s performance as wellas robustness.Extensive experiments conducted on four real-world datasetsfurther verify the effectiveness of the proposed learning paradigm,which improves performance and robustness,even when recommender systemsfaceheavy data sparsity issues.",No.,0.0,0.0,0.0,9.652434877402245,28.48837209302325,31.80100755667506,0.1785714285714285,0.0024937655860349,0.2240986377000808,1.0,0.2240986377000808,,0.0524285276629869,0.9577127695083618,4,0.0,5.0,0.0,0.8383662899453898,0.9684202213939548,0.8736808855758189,0.0,0.9577127695083618
46,46,What metrics are used to measure the robustness of the model?,No metrics are mentioned for explicitly measuring robustness.,"We follow (Wanget al., 2019a; Krichene andRendle, 2020) to rank the prediction on the whole item set without negative sampling.Performance isevaluated ona variety of evaluation metrics, including Hit Ratio@k (\mathrm{HR}@k), and Normalized DiscountedCumulative Gain@k (\mathrm{NDCG}@k) where k\in\{5,20\}.",HR@k and NDCG@k.,0.0,0.0,0.0,4.767707020457095,3.787878787878788,5.436046511627906,0.0561797752808988,0.0037359900373599,-0.0206149369478225,0.2011998724192381,-0.0206149388104677,,0.003106898415749,0.0542571209371089,1,1.0,0.0,1.0,0.8940191139734774,0.1887416718364398,0.7549666873457594,0.0,0.0542571209371089
47,47,Does the parallelization of transformer part of the proposed method reduce time complexity effectively?,"Logically, yes. Empirically, no.","In every iteration of the training phase,the computation costsof our proposed methodare mainly fromthe E-step estimation of Q(\cdot) and M-step optimization of \thetawith multi-tasks training.For the E-step,the time complexity is O(|U|mKd) from clustering, where d is the dimensionalityof the embedding and m is themaximum iteration number in clustering (m=20 in this paper).For the M-step,since we have three objectivesto optimize the network f_{\theta}(\cdot),the time complexity is O(3⋅(|U|2d+|U|d2)O(3\cdot(|U|^{2}d+|U|d^{2})italic_O ( 3 ⋅ ( | italic_U | start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT italic_d + | italic_U | italic_d start_POSTSUPERSCRIPT 2 end_POSTSUPERSCRIPT ).The overall complexity is dominated by the term O(3\cdot(|U|^{2}d)),which is 3 times of Transformer-based SR with only next item prediction objective, e.g., SASRec.Fortunately,the model can be effectively parallelized becausef_{\theta} is Transformer and we leave it in future work.In the testing phase,the proposed ICL as wellas the SeqCL objectivesare no longer needed, which yields themodel to have the sametime complexity as SASRec (O(d|V|)).The empirical time spending comparisonsare reported in Sec. 5.2.The convergence of ICL is guaranteedunder the generalized EM framework.Proof is provided in Appendix B.",No.,0.0,0.0,0.0,5.522397783539471,12.838770930433284,14.80628771038425,0.2533783783783783,0.0033222591362126,0.2968536913394928,0.0765839591622352,0.3162409365177154,,0.020680158391228,0.4229006171226501,3,0.0,1.0,1.0,0.796783071554772,0.5777597183792216,0.8110388735168863,0.0,0.4229006171226501
48,48,What are some examples of the SR model that uses deep neural network to encode user behavior sequences?,BERT4Rec and S3-Rec are two examples,"•Non-sequential models:BPR-MF (Rendle et al., 2012) characterizesthe pairwise interactionsvia a matrix factorization model andoptimizes through apair-wiseBayesian Personalized Ranking loss.•Standard sequential models.We include solutionsthat train the models with a next-itemprediction objective.Caser (Tang and Wang, 2018) is a CNN-based approach, GRU4Rec (Hidasi et al., 2015)is an RNN-based method, and SASRec (Kang and McAuley, 2018) is one of the state-of-the-art Transformer-basedbaselines for SR.•Sequential models with additional SSL:BERT4Rec (Sunet al., 2019)replaces the next-item prediction witha Cloze task (Taylor, 1953)tofuse informationbetween an item (a view) in a userbehavior sequence and its contextual information.S{}^{3}\text{-Rec} (Zhou et al., 2020) uses SSL to capture correlation-ship among item, sub-sequence, and associated attributes from the given user behavior sequence.Its modules for mining on attributes are removedbecause we don’t have attributes for items,namely S{}^{3}\text{-Rec}_{ISP}.CL4SRec (Xieet al., 2020) fusescontrastive SSL with aTransformer-based SR model.•Sequential models considering latent factors:We include DSSRec(Maet al., 2020),which utilizes seq2seq trainingand performs optimization inlatent space.We do not directly compare ASLI (Tanjim et al., 2020),as it requires user action type information (e.g.,click, add-to-favorite, etc).Instead, we provide a case study inSec. 5.6 toevaluate the benefits of the learnt intent factorwith additional item category information.
Sequential recommendation aimsto accurately characterize users’ dynamic interestsby modeling their past behavior sequences (Rendle, 2010; Rendle et al., 2010; Kang and McAuley, 2018; Chen et al., 2021; Liet al., 2021a; Liuet al., 2021a).Early works on SR usually modelanitem-to-item transaction patternbased on MarkovChains (Rendle, 2010; He and McAuley, 2016).FPMC (Rendle et al., 2010)combines the advantages of Markov Chainsand matrix factorizationto fuse both sequential patternsand users’ general interest.With the recent advances of deep learning,many deep sequential recommendation modelsare also developed (Tang and Wang, 2018; Hidasi et al., 2015; Kang and McAuley, 2018; Sunet al., 2019). Such as Convolutional Neural Networks (CNN)-based (Tang and Wang, 2018) andRNN-based (Hidasi et al., 2015) models.The recent success of Transformer (Vaswani et al., 2017)also motivatesthe developments of pure Transformer-based SR models.SASRec (Kang and McAuley, 2018)utilizes unidirectional Transformerto assign weights to each interacted item adaptively.BERT4Rec (Sunet al., 2019) improves that byutilizing a bidirectional Transformerwith a Cloze task (Taylor, 1953)to fuse user behaviors information fromleft and right directions into each item.LSAN (Liet al., 2021a) improves SASRecon reducing model size perspective.It proposes a temporal context-aware embeddingand twin-attention network, which are light weighted.ASReP (Liuet al., 2021b) further alleviatesthe data-sparsity issueby leveraging a pre-trained Transformeron the revised user behavior sequences toaugment short sequences.In this paper, we study thepotential of addressing data sparsity issuesand improving SR via self-supervised learning.","SASRec, BERT4Rec, LSAN, ASReP.",0.0,0.0,0.0,5.522397783539471,26.267451966991462,21.395079476072446,0.0806451612903225,0.0066225165562913,0.5884555578231812,0.0162483945488929,0.5884554386138916,0.0013075717724859,0.0099040603776771,0.6283453106880188,4,1.0,2.0,1.0,0.8477794004929171,0.5928748872447751,0.8714995489791005,0.0,0.6283453106880188
49,49,How sparse is the real-world dataset used in the experiment?,They are about 99.95% sparse.,"We follow (Zhou et al., 2020; Xieet al., 2020) to prepare the datasets. In detail, we only keep the ‘5-core’ datasets, in which all users and items have at least 5 interactions. The statistics of the prepared datasets are summarized inAppendix C.",Very sparse.,0.24999999625,0.0,0.24999999625,13.134549472120788,42.16419507925753,42.70648521589869,0.2840909090909091,0.0049751243781094,0.7679842114448547,0.5833333333333333,0.76798415184021,,0.0185983915877069,0.6130256056785583,4,0.0,2.0,,0.0,0.2288568064262418,0.9154272257049672,0.0,0.6130256056785583
50,50,What was the value of maximum length T used for the experiment and how was the ratio of sequences that longer than length T?,"The value of T is not mentioned, and neither is the ratio of sequences that exceed T in length.","Assume that a recommender system has a set of usersand items denoted by \mathcal{U} and \mathcal{V} respectively.Each user u\in\mathcal{U} has a sequence of interacted itemssorted in chronological order S^{u}=[s^{u}_{1},\dots,s^{u}_{t},\dots,s^{u}_{|S^{u}|}]where |S^{u}| is the number of interacted itemsand s^{u}_{t} is the item u interacted atstep t. We denote \mathbf{S}^{u}as embedded representation of S^{u},where \mathbf{s}^{u}_{t} is the d-dimensional embedding of item s^{u}_{t}.In practice, sequences are truncated withmaximum length T.If the sequence length is greater than T, the mostrecent T actions are considered. If the sequence length is less than T, ‘padding’ items will beadded to the left until the length isT (Tang and Wang, 2018; Hidasi et al., 2015; Kang and McAuley, 2018).For each user u,the goal of next item prediction task is to predictthe next item that the user uis most likely to interact withat the |S_{u}|+1 step among the item set \mathcal{V},given sequence \mathbf{S}^{u}.",Not provided in the given context.,0.1818181778512397,0.0,0.0909090869421489,2.3901021968803136,17.469102785843784,16.937402536163606,0.1020408163265306,0.003516998827667,0.2560005486011505,0.3830714596284401,0.2560005486011505,0.2542663216590881,0.0180543774865381,0.0811745226383209,1,0.0,5.0,,0.7573115741763976,0.1926686276711357,0.770674510684543,0.0,0.0811745226383209
51,51,How does the paper show that the clustering result can be interpreted as users' intent?,It does not. K as a hyperparameter is only best believed as the number of user intents and does not necessarily equal the actual number of user intents.,"The main goal of next item prediction task is to optimizeEq. (1).Assume that there are also K different user intents (e.g., purchasing holiday gifts, preparing for fishing activity, etc.)in a recommender system that formsthe intent variable c=\left\{c_{i}\right\}_{i=1}^{K}, thenthe probability of a user interacting with a certainitem can be rewritten as follows:(7)\begin{split}P_{\theta}(s^{u})=\mathbb{E}_{(c)}\left[P_{\theta}(s^{u},c)\right].\end{split}However, users intents are latent by definition.Because of the missing observation of variable c,we are in a ‘chicken-and-eggs’ situation thatwithout c, we cannot estimate parameter \theta,and without \theta we cannot inferwhat the value of c might be.
The larger of the intent class number K means users can havemore diverseintentions.The larger value of the strength of SeqCL objective \betameans the ICL task contributes more tothe final model.The results on Yelp is shown in Figure 5.We find that: (1)ICLRec reaches itsbest performance when increasing K to 512,and then it starts to deteriorateas K become larger.When K is very small,the number of users undereach intent prototype can potentially be large.As a result, false-positive samples(i.e., users that actually have different intentsare considered as having the same intent erroneously)are introduced to the contrastive SSL,thus affecting learning.On the other hand, when K is too large,the number of users undereach intent prototype is small,the introduced false-negative sampleswill also impair contrastive SSL.In Yelp, 512 user intents summarizeusers’ distinct behaviors best.(2) A ‘sweet-spot’ of \lambda=0.5 canalso be found.It indicatesthat the ICL task can benefitthe recommendation predictionas an auxiliary task.The impact of the batch size and \beta are provided in Appendix D.
Recently, many approaches have been proposed to studyusers’ intents forimproving recommendations (Wanget al., 2019b; Cenet al., 2020; Li et al., 2019; Liet al., 2021b).MCPRN (Wanget al., 2019b)designs mixture-channel purposerouting networks to adaptivelylearnusers’ different purchase purposesof each itemunder different channels (sub-sequences) for session-based recommendation.MITGNN(Liuet al., 2020a)proposes amulti-intenttranslation graph neural networkto mine users’ multiple intentsby considering the correlations of the intents.ICM-SR (Panet al., 2020)designs anintent-guided neighbor detectorto retrieve correctneighbor sessionsfor neighbor representation.Different from session-based recommendation,another line of worksfocus on modeling the sequentialdynamics of users’ interaction behaviorsin a longer time span.DSSRec (Maet al., 2020)proposes a seq2seq trainingstrategy using multiple future interactions as supervision and introducing an intent variable from her historical and future behavior sequences.The intent variable is used to capture mutual information between an individual user’s historical and future behavior sequences.Two users of similar intentsmight be far away in representation space.Unlike this work, our intent variable is learned over all users’ sequences and is used to maximize mutual information across different users with similar learned intents.ASLI (Tanjim et al., 2020)captures intentvia a temporal convolutionalnetwork with side information (e.g., user action types such asclick, add-to-favorite, etc.),and then use the learnedintents toguide SR model to predictthe next item.Instead, our methodcan learn users’ intentsbased on user interactiondata only.","By showing that the intent class number K affects the performance of the model, and that a 'sweet-spot' of K=512 is found, indicating that the clustering result can be interpreted as users' intent.",0.3478260820415879,0.0,0.1739130385633271,1.7317334823069537,23.37754569509096,21.3114026960796,0.2890331890331891,0.0105330354293009,0.4749554991722107,0.6541653535800215,0.4844699501991272,0.5611834526062012,0.0148525705337689,0.2253133356571197,3,1.0,1.0,,0.8047509417233666,0.216569305545411,0.8662772221816442,0.0,0.2253133356571197
52,52,Why does the proposed method introduced EM framework to optimize the model (instead of directly optimizing the loss)?,EM guarantees convergence.,"Later, we will show that a generalized Expectation-Maximization frameworkprovides a direction to address above problemwith a convergence guarantee.The basic idea of optimizing Eq. (7) via EMis to start with an initial guessof the model parameter \thetaand estimate the expected valuesof the missing variable c, i.e., the E-step.And once we have the values of c,we can maximize the Eq. (7) w.r.t theparameter \theta, i.e., the M step.We can repeat this iterative process until the likelihood cannot increase anymore.
To discover the benefits oflatent intentsand address challenges,we propose theIntent Contrastive Learning (ICL),a general learning paradigm thatleverages the latent intentfactor into SR.It learns users’ intentdistributionsfrom all user behavior sequencesvia clustering.And it leveragesthe learnt intentsinto the SR modelvia a new contrastive SSL,whichmaximizes the agreementbetween a view of sequenceand its corresponding intent.The intent representation learning moduleand the contrastive SSL module are mutually reinforcedto train a more expressivesequence encoder.We tackle the challenge of intentmining problem byintroducing alatent variable to represent users’ intentsand learn them alternatelyalong with the SR model optimization throughan expectation-maximization (EM) frameworkto ensure convergence.We suggest fusing learnt intent informationinto SR via the proposed contrastive SSL,as it can improve model’s performance as wellas robustness.Extensive experiments conducted on four real-world datasetsfurther verify the effectiveness of the proposed learning paradigm,which improves performance and robustness,even when recommender systemsfaceheavy data sparsity issues.
In this work,we propose a new learning paradigm ICL that canmodel latent intent factorsfrom user interactionsand fuse them into a sequential recommendationmodel via a newcontrastive SSL objective.ICL is formulated withinan EM framework, which guaranteesconvergence. Detailed analyses showthe superiority of ICL andexperiments conducted onfour datasets further demonstratethe effectiveness of the proposed method.",To ensure convergence.,0.3333333283333334,0.0,0.3333333283333334,31.947155212313625,56.29853217114235,52.70158372873964,0.46875,0.0147783251231527,0.5372248888015747,0.5711221277713775,0.5372248291969299,,0.0160702742289144,0.9660984873771667,4,1.0,5.0,1.0,0.8976136322773628,0.7120961508388565,0.8483846033554258,0.8,0.9660984873771667
53,53,How does temporal context-aware embedding and twin-attention network enable LSAN to be lightweighted compared to SASRec?,Authors do not discuss how.,"Sequential recommendation aimsto accurately characterize users’ dynamic interestsby modeling their past behavior sequences (Rendle, 2010; Rendle et al., 2010; Kang and McAuley, 2018; Chen et al., 2021; Liet al., 2021a; Liuet al., 2021a).Early works on SR usually modelanitem-to-item transaction patternbased on MarkovChains (Rendle, 2010; He and McAuley, 2016).FPMC (Rendle et al., 2010)combines the advantages of Markov Chainsand matrix factorizationto fuse both sequential patternsand users’ general interest.With the recent advances of deep learning,many deep sequential recommendation modelsare also developed (Tang and Wang, 2018; Hidasi et al., 2015; Kang and McAuley, 2018; Sunet al., 2019). Such as Convolutional Neural Networks (CNN)-based (Tang and Wang, 2018) andRNN-based (Hidasi et al., 2015) models.The recent success of Transformer (Vaswani et al., 2017)also motivatesthe developments of pure Transformer-based SR models.SASRec (Kang and McAuley, 2018)utilizes unidirectional Transformerto assign weights to each interacted item adaptively.BERT4Rec (Sunet al., 2019) improves that byutilizing a bidirectional Transformerwith a Cloze task (Taylor, 1953)to fuse user behaviors information fromleft and right directions into each item.LSAN (Liet al., 2021a) improves SASRecon reducing model size perspective.It proposes a temporal context-aware embeddingand twin-attention network, which are light weighted.ASReP (Liuet al., 2021b) further alleviatesthe data-sparsity issueby leveraging a pre-trained Transformeron the revised user behavior sequences toaugment short sequences.In this paper, we study thepotential of addressing data sparsity issuesand improving SR via self-supervised learning.",Temporal context-aware embedding and twin-attention network are light weighted.,0.0,0.0,0.0,4.167251645138561,5.170963853885241,5.267723740598043,0.078125,0.0099009900990099,-0.0066498150117695,0.3313698748062397,-0.0066498084925115,,0.0034885522682183,0.0817365273833274,3,1.0,1.0,1.0,0.8487074989103093,0.1819055950018442,0.7276223800073769,0.4,0.0817365273833274
54,54,What properties of costrastive self-supervised learning have attracted attention from researchers in the recommendation field?,Sequences of user behavior can be maximally separated or brought together by means of contrastive SSL.,"Recent advances in contrastive SSLhave inspired therecommendation communityto leverage contrastive SSL tofuse correlations amongdifferent views of one sequence (Chenet al., 2020; Yao et al., 2020; Wuet al., 2021),following themutual information maximization (MIM) principle.Existing approaches in SRcan be seen asinstance discrimination tasksthat optimize a lower bound of MIM,such as InfoNCE (Oordet al., 2018; Heet al., 2020b; Chenet al., 2020; Liet al., 2020b).It aims to optimize theproportion of gap of positive pairs and negative pairs (Liu et al., 2021c).In such an instance discrimination task,sequence augmentations such as ‘mask’, ‘crop’, or ‘reorder’ are required tocreatedifferent views of the unlabeled data in SR (Sunet al., 2019; Zhou et al., 2020; Xieet al., 2020; Zhou et al., 2021).Formally, given a sequence S^{u},and a pre-defined data transformationfunction set \mathcal{G}, we can createtwo positive views of S^{u} as follows:(4)\tilde{S}^{u}_{1}=g_{1}^{u}(S^{u}),\tilde{S}^{u}_{2}=g_{2}^{u}(S^{u}),\text{ s.t. }g_{1}^{u},g_{2}^{u}\sim\mathcal{G},where g_{1}^{u} and g_{2}^{u} are transformation functions sampledfrom \mathcal{G} to createa different view of sequence s_{u}.Commonly, views created from the same sequenceare treated as positive pairs,and the views of any different sequencesare considered as negative pairs.The augmented views are first encoded with thesequence encoder f_{\theta}(\cdot) to\mathbf{\tilde{H}}^{u}_{1} and \mathbf{\tilde{H}}^{u}_{2},and then be fed into an ‘Aggregation’layer to get vector representationsof sequences, denoted as \mathbf{\tilde{h}}^{u}_{1} and \mathbf{\tilde{h}}^{u}_{2}. In this paper,we ‘concatenate’ users’ interest representations over time stepsfor simplicity. Note that sequences are prepossessed to have the same length (See Sec. 3.1), thustheir vector representations after concatenationhave the same length too.After that,we can optimize \theta via InfoNCE loss:(5)\mathcal{L}_{\mathrm{SeqCL}}=\mathcal{L}_{\mathrm{SeqCL}}(\mathbf{\tilde{h}}^{u}_{1},\mathbf{\tilde{h}}^{u}_{2})+\mathcal{L}_{\mathrm{SeqCL}}(\mathbf{\tilde{h}}^{u}_{2},\mathbf{\tilde{h}}^{u}_{1}),and(6)\mathcal{L}_{\mathrm{SeqCL}}(\mathbf{\tilde{h}}^{u}_{1},\mathbf{\tilde{h}}^{u}_{2})=-\log\frac{\exp(\text{sim}(\mathbf{\tilde{h}}^{u}_{1},\mathbf{\tilde{h}}^{u}_{2}))}{\sum_{neg}\exp(\text{sim}(\mathbf{\tilde{h}}^{u}_{1},\mathbf{\tilde{h}}_{neg}))},where sim(\cdot) is dot product and\mathbf{\tilde{h}}_{neg} are negativeviews’ representations of sequence S^{u}.Figure 2(a) illustrates how SeqCL works.
Sequential recommendation aimsto accurately characterize users’ dynamic interestsby modeling their past behavior sequences (Rendle, 2010; Rendle et al., 2010; Kang and McAuley, 2018; Chen et al., 2021; Liet al., 2021a; Liuet al., 2021a).Early works on SR usually modelanitem-to-item transaction patternbased on MarkovChains (Rendle, 2010; He and McAuley, 2016).FPMC (Rendle et al., 2010)combines the advantages of Markov Chainsand matrix factorizationto fuse both sequential patternsand users’ general interest.With the recent advances of deep learning,many deep sequential recommendation modelsare also developed (Tang and Wang, 2018; Hidasi et al., 2015; Kang and McAuley, 2018; Sunet al., 2019). Such as Convolutional Neural Networks (CNN)-based (Tang and Wang, 2018) andRNN-based (Hidasi et al., 2015) models.The recent success of Transformer (Vaswani et al., 2017)also motivatesthe developments of pure Transformer-based SR models.SASRec (Kang and McAuley, 2018)utilizes unidirectional Transformerto assign weights to each interacted item adaptively.BERT4Rec (Sunet al., 2019) improves that byutilizing a bidirectional Transformerwith a Cloze task (Taylor, 1953)to fuse user behaviors information fromleft and right directions into each item.LSAN (Liet al., 2021a) improves SASRecon reducing model size perspective.It proposes a temporal context-aware embeddingand twin-attention network, which are light weighted.ASReP (Liuet al., 2021b) further alleviatesthe data-sparsity issueby leveraging a pre-trained Transformeron the revised user behavior sequences toaugment short sequences.In this paper, we study thepotential of addressing data sparsity issuesand improving SR via self-supervised learning.
Contrastive Self-Supervised Learning (SSL)has brought much attentions bydifferent research communitiesincluding CV (Chenet al., 2020; Liet al., 2020b; Heet al., 2020b; Caron et al., 2020; Khosla et al., 2020) andNLP (Gao et al., 2021; Gunelet al., 2020; Mnih andKavukcuoglu, 2013; Zhanget al., 2020),as well asrecommendation(Yao et al., 2020; Zhou et al., 2020; Wuet al., 2021; Xieet al., 2020).The fundamental goal of contrastive SSLis to maximize mutual informationamong the positive transformationsof the data itself whileimprovingdiscrimination abilityto the negatives.In reccommendation,A two-tower DNN-basedcontrastive SSLmodel is proposed in (Yao et al., 2020).Itaimstoimproving collaborative filteringbasedrecommendation leveraging item attributes.SGL (Wuet al., 2021) adoptsa multi-task framework withcontrastive SSL to improve thegraph neural networks (GCN)-basedcollaborative filtering methods (Heet al., 2020a; Wanget al., 2019a; Liuet al., 2020b; Zhang and McAuley, 2020)with only item IDs as features.Specific to SR,S{}^{3}\text{-Rec} (Zhou et al., 2020)adopts a pre-training andfine-tuning strategy, and utilizescontrastive SSL during pre-trainingto incorporate correlationsamong items, sub-sequences, and attributes of a givenuser behavior sequence.However, the two-stage training strategyprevents the information sharing between next-item prediction and SSL tasks and restrictsthe performance improvement.CL4SRec (Xieet al., 2020) andCoSeRec (Liuet al., 2021a)insteadutilize a multi-task training frameworkwith a contrastive objectiveto enhance user representations.Different from them, our work is aware ofusers’ latent intent factor whenleveraging contrastive SSL,which we show to bebeneficial forimproving recommendationperformanceand robustness.",mutual information maximization and discrimination ability.,0.0,0.0,0.0,2.2869567780619007,16.08335562723186,13.494814965396474,0.0625,0.0037359900373599,0.2047194540500641,0.2970538903837617,0.2047194391489029,0.1299908012151718,0.0029897234526885,0.052192460745573,4,1.0,1.0,1.0,0.8365197824748384,0.6934571169779681,0.7738284679118723,0.8,0.052192460745573
55,55,Can the proposed methodology utilize user intent information associated with user interaction data if available?,"Yes, it can.","Robustness w.r.t. user interaction frequency.Theuser ‘cold-start’ problem (Caiet al., 2021; Yinet al., 2020) is one of thetypical data-sparsity issues thatrecommender systems often face, i.e.,most users have limited historical behaviors.To check whether ICL improves the robustnessunder such a scenario,wesplit user behavior sequences into three groupsbased on their behavior sequences’ length, and keepthe total number of behavior sequencesthe same.Models are trained and evaluated on each group of usersindependently. Figure 3shows the comparison results on four datasets.We observe that:(1) The proposed ICLRec canconsistentlyperforms better thanSASRec among all user groups whileCL4SRec fails to outperform SASRecin Beauty and Yelpwhen user behavior sequences areshort.This demonstrates thatCL4SRec requires individual userbehavior sequences long enough to provide‘complete’ informationfor auxiliary supervisionwhileICLRec reducesthe need by leveraginguser intent information,thus consistently benefiting userrepresentation learning evenwhen users have limited historical interactions.(2) Compared with CL4SRec,we observe thatthe improvement of ICLRec is mainly becauseit provides betterrecommendations tousers with low interaction frequency.Thisverifies thatuser intent informationis beneficial, especiallywhen the recommender system facesdata-sparsity issues whereinformationin each individual user sequenceis limited.",Yes.,0.0,0.0,0.0,12.703318703865364,39.25332255747127,39.03514008277618,0.2127659574468085,0.0033222591362126,0.3285117149353027,1.0,0.3285116553306579,,0.0468206389760722,0.9729177355766296,4,0.0,5.0,,0.7881439675183879,0.9753089726911612,0.9012358907646448,1.0,0.9729177355766296
56,56,What does the proposed method BUIR require instead of negative sampling for training?,BUIR requires positive user-item pairs instead of negative sampling for training.,"For all the datasets, BUIRid shows the substantially higher performance than the discriminative methods taking only user-id/item-id (i.e., BPR, NeuMF, CML, and SML).In particular, the sparser the training set becomes, the larger the performance improvement of BUIRid is achieved over the best baseline (denoted by Improvid).It is obvious that BUIRid is more robust to the extreme sparsity compared to the other baselines that are more likely to explicitly use “positive but unobserved” interactions as negative interactions when positive user-item interactions are more rarely observed.BUIRid is not affected by such inconsistent supervision from uncertain negative interactions because it directly optimizes the representations of users and items by using only positive interactions.
As a solution to the aforementioned limitations, this paper proposes a novel OCCF framework, named as BUIR, which does not require the negative sampling at all for training the model.The main idea is, given a positive user-item interaction (u, v), to make representations for u and v similar to each other, in order to encode the preference information into the representations.However, a naive end-to-end learning framework that guides positive user-item pairs to be similar to each other without any negative supervision can easily converge to a collapsed solution – the encoder network outputs the same representations for all the users and items.
First of all, the BPR framework that optimizes the cross-prediction score, q\left(f(u)\right)^{\top}f(v)+f(u)^{\top}q\left(f(v)\right), is not as effective as ours;it is even worse compared to the conventional BPR, which optimizes the inner-product score f(u)^{\top}f(v).This implies that the performance improvement of BUIR is mainly caused by our learning framework rather than its score modeling based on the predictor.In addition, even without the stochastic augmentation, the neighbor-based encoder (i.e., LGCN) based on the BUIR framework beats LGCN based on the BPR framework, which demonstrates that BUIR successfully addresses the issue of incorrect negative sampling.Lastly, our framework with the stochastic neighbor augmentation further improves the performance by taking benefits from various views of the positive user-item interactions for the optimization.
This paper proposes a novel framework for learning the representations of users and items, termed as BUIR, to address the main challenges of the OCCF problem: the implicit assumption about negative interactions, and high sparsity of observed (positively-labeled) interactions.First, BUIR directly bootstraps the representations of users and items by minimizing their cross-prediction error.This makes BUIR use only partially-observed positive interactions for training the model, and accordingly, it can eliminate the need for negative sampling.In addition, BUIR is able to learn the augmented views of each positive interaction obtained from the neighborhood information, which further relieves the data sparsity issue of the OCCF problem.Through the extensive comparison with a wide range of OCCF methods, we demonstrate that BUIR consistently outperforms all the other baselines in terms of top-K recommendation.In particular, the effectiveness of BUIR becomes more significant for much sparse datasets in which the positively-labeled interactions are not enough to optimize the model as well as the assumption about negative interactions becomes less valid.Based on its great compatibility with existing user/item encoder networks, we expect that our BUIR framework can be a major solution for the OCCF problem, replacing the conventional BPR framework.
Our extensive evaluation on real-world implicit feedback datasets shows that BUIR consistently performs the best for top-K recommendation among a wide range of OCCF methods.In particular, the performance improvement becomes more significant in sparser datasets, with the help of utilizing augmented views of positive interactions as well as eliminating the effect of uncertain negative interactions.In addition, comparison results on a downstream task, which classifies the items into their category, support that BUIR learns more effective representations than other OCCF baselines.",positive interactions.,0.1538461512426036,0.0,0.1538461512426036,4.02724819242185,28.81889983146198,26.83589861283356,0.09009009009009,0.0019960079840319,0.2021992802619934,0.658822516600291,0.2021992802619934,0.7159693241119385,0.0032327512308594,0.1802349686622619,3,1.0,2.0,1.0,0.8187959872711826,0.6972774889107722,0.7891099556430892,1.0,0.1802349686622619
57,57,Is it true that approximating the online encoder slowly make the target encoder keep from converging to the collapsed solution?,Approximating the online encoder keep the target encoder from converging to the collapsed solution.,"Bypassing the collapsed solution.  It is obvious that the loss in Equation (3) admits the collapsed solution with respect to \theta and \xi, which means both the encoders generate the same representations for all users and items.For this reason, the conventional end-to-end learning strategy, which optimizes both f_{\theta} and f_{\xi} to minimize the loss (i.e., cross-prediction error), may easily lead to such collapsed solution.In contrast, our proposed framework updates each of the encoders in different ways.From Equation (4), the online encoder is optimized to minimize the loss, while the target encoder is updated to slowly approximate the online encoder.That is, the direction of updating the target encoder (\theta-\xi) totally differs from that of updating the online encoder (-\nabla_{\theta}\mathcal{L}_{\theta,\xi}),and this effectively keeps both the encoders from converging to the collapsed solution.Several recent work on bootstrapping-based representation learning (Grill et al., 2020; Chen and He, 2021) empirically demonstrated that this kind of dynamics (i.e., updating two networks differently) allows to avoid the collapsed solution without any explicit term to prevent it.",Yes.,0.0,0.0,0.0,2.627961710408444,3.6764705882352944,6.387003666432638,0.0364963503649635,0.0007137758743754,0.0536852404475212,0.30049929022789,0.0536852329969406,,0.0057104702063775,0.0517656169831752,4,0.0,1.0,1.0,0.8438868170768338,0.9274754389208324,0.70990175568333,1.0,0.0517656169831752
58,58,What component of the model eliminates the effect of uncertain negative interactions after the positive interaction augmentation?,Online encoders prevent models from collapsing into trivial solutions without explicitly using negative interactions for optimization.,"We argue that the above collapsed solution is incurred by the si\x02multaneous optimization of 𝑢 and 𝑣 within the end-to-end learning framework of a single encoder. Hence, we instead adopt the student\x02teacher-like network [6, 29] in which only the student’s output 𝑢 (and 𝑣) is optimized to predict the target 𝑣 (and 𝑢) presented by the teacher. Specifically, BUIR directly bootstraps1 the representations of users and items by employing two distinct encoder networks, referred to as online encoder and target encoder. The high-level idea is training only the online encoder for the prediction task between 𝑢 and 𝑣, where the target for its prediction is provided by the target encoder. That is, the online encoder is optimized so that its user (and item) vectors get closer to the item (and user) vectors com\x02puted by the target encoder. At the same time, the target encoder is updated based on momentum-based moving average [6, 8, 29] to slowly approximate the online encoder, which encourages to pro\x02vide enhanced representations as the target for the online encoder. By doing so, the online encoder can capture the positive relation\x02ship between 𝑢 and 𝑣 into the representations, while preventing the model from collapsing to the trivial solution without explicitly using any negative interactions for the optimization.",The target encoder.,0.0,0.0,0.0,2.2869567780619007,17.18770409273731,14.916663177798323,0.0636942675159235,0.0018714909544603,0.4342351257801056,0.5211325153708457,0.4342350363731384,0.3842657804489136,0.0032101658812338,0.0884414240717887,1,1.0,1.0,0.0,0.7489139464275372,0.1997787999740131,0.7990200203754115,0.8,0.0884414240717887
59,59,What are the benefits of using the predictor to calculate user-item interaction score instead of directly encoding into their inner product?,Using predictor can optimize the representation without any negative sample.,"Existing discriminative OCCF methods (Rendle et al., 2009; Hsieh et al., 2017) have tried to optimize the latent space where the user-item interactions are directly encoded into their inner product (or Euclidean distance).On the contrary, BUIR additionally uses the predictor to model their interaction, which results in the capability of encoding the high-level relationship between users and items into the representations.In conclusion, with the help of the predictor, BUIR accurately computes the user-item interaction scores as well as optimizes the representation without explicitly using negative samples.",Encoding high-level relationship between users and items.,0.0,0.0,0.0,3.747776736677921,20.808703349703663,17.060474761647008,0.0467289719626168,0.0069513406156901,0.1751005947589874,0.4160629735949138,0.1751005947589874,0.1665427088737487,0.0121212627901841,0.0674957185983657,3,1.0,1.0,,0.7499652843262504,0.1851165114743387,0.7404660458973549,0.8,0.0674957185983657
60,60,"What does ""stochastic"" mean in the stochastic data augmentation technique that the author introduced?",Stochastic means it use random neighborhood information of each user and item during data augmentation.,"In Figure 4, our stochastic data augmentation (i.e., P>0) brings a significant improvement compared to the case of using the fixed neighborhood information (i.e., P=0) as encoder inputs.This result shows that the augmented views of positive interactions encourage BUIR to effectively learn users’ preference on items even in much sparse dataset.Interestingly, in case of the Ciao dataset which is less sparse than CiteULike, the benefit of our augmentation linearly increases with the maximum drop probability.This is because there is room for producing more various views (i.e., larger perturbation) based on a relatively more number of neighbors, and it eventually helps to boost the recommendation performance.To sum up, our framework that adopts the neighbor augmentation function successfully relieves the data sparsity issue of the OCCF problem, by leveraging the augmented views of few positive interactions.
Furthermore, we introduce a stochastic data augmentation technique to relieve the data sparsity problem in our framework.Motivated by the recent success of self-supervised learning in various domains (Chenet al., 2020; Devlinet al., 2019), we exploit augmented views of an input interaction, which are generated based on the neighborhood information of each user and item (i.e., the set of the items interacted with a user, and the users interacted with an item).The stochastic augmentation is applied to positive user-item pairs when they are passed to the encoder, so as to produce the different views of the pairs.To be precise, by making our encoder use a random subset of a user’s (and item’s) neighbors for the input features, it produces a similar effect to increasing the number of positive pairs from the data itself without any human intervention.In the end, BUIR is allowed to learn various views of each positive user-item pair.",Random or probabilistic.,0.0,0.0,0.0,2.445593937240363,16.927228610393517,14.649410907515676,0.0675675675675675,0.0021382751247327,0.4203053414821625,0.8939622640609741,0.4203054010868072,,0.0097322802997338,0.097200371325016,3,0.5,4.0,1.0,0.8468349376502117,0.7126409120857131,0.8505636483428524,0.0,0.097200371325016
61,61,What value of momentum coefficient (τ) makes the BULR model perform best?,Model gets best performance when the value of parameter tau is larger or equal than 0.9 and smaller than 1.,"Implementation Details.  We implement the proposed framework and all the baselines by using PyTorch, and use the Adam optimizer to train them.For BUIR, we fix the momentum coefficient \tau to 0.995, and adopt a single linear layer for the predictor q_{\theta}.666We empirically found that these hyperparameters hardly affect the final performance of BUIR, and the sensitivity analysis on the parameters is provided in Section 4.6.The augmentation function \psi simply uses a uniform distribution for drawing a drop probability p\sim\mathcal{U}(0,1), where each user’s (item’s) neighbor is independently deleted with the probability p.
Figure 6 clearly shows that the performance is hardly affected by \tau in the range of [0.9, 1.0).In other words, any values of \tau larger than 0.9 allow the target encoder to successfully provide the target representations to the online encoder, by slowly approximating the online encoder;on the contrary, BUIR cannot learn the effective representations at all in case that the target encoder is fixed (i.e., \tau=1).This observation is consistent with previous work on momentum-based moving average (Tarvainen andValpola, 2017; Heet al., 2020b; Grill et al., 2020) that showed all values of \tau between 0.9 and 0.999 can yield the best performance.Furthermore, BUIR performs the best with a single-layer predictor, because a multi-layer predictor makes it difficult to optimize the relationship between outputs of the two encoder networks.In conclusion, BUIR is more powerful even with fewer hyperparameters, compared to existing OCCF methods that include a variety of regularization terms or modeling components.",The answer is 0.995.,0.1599999968,0.0,0.1599999968,2.159701133933343,11.363038006334731,11.60009799634378,0.0773195876288659,0.0022172949002217,0.166468933224678,0.1910285296894256,0.166468933224678,,0.0214244011930742,0.1201192140579223,3,1.0,2.0,1.0,0.8703529491728013,0.6938010514155228,0.7748283487325294,0.0,0.1201192140579223
62,62,"In BUIR, how does the online encoder updated compared to the target encoder?","The online encoder is updated to minimize the error between the output and the target and updated by the gradients back-propagated from the loss, but target network is updated based on the momentum update and updated as the moving average of the online encoder .","BUIR makes use of two distinct encoder networks that have the same structure: online encoder f_{\theta} and target encoder f_{\xi}.They are parameterized by \theta and \xi, respectively.The key idea of BUIR is to train the online encoder by using outputs of the target encoder as its target, while gradually improving the target encoder as well.The main difference of BUIR from existing end-to-end learning frameworks is that f_{\theta} and f_{\xi} are updated in different ways.The online encoder is trained to minimize the error between its output and the target, whereas the target network is slowly updated based on the momentum update (Heet al., 2020b) so as to keep its output consistent.
To sum up, the parameters of the online encoder and target encoder are optimized by(4)\begin{split}\theta&\leftarrow\theta-\eta\cdot\nabla_{\theta}\mathcal{L}_{\theta,\xi}\\\xi&\leftarrow\tau\cdot\xi+(1-\tau)\cdot\theta.\end{split}\eta is the learning rate for stochastic optimization, and \tau\in[0,1] is a momentum coefficient (also called as target decay) for momentum-based moving average.The online encoder f_{\theta} (and the predictor q_{\theta}) is effectively optimized by the gradients back-propagated from the loss (Equation (3)), while the target encoder f_{\xi} is updated as the moving average of the online encoder.By taking a large value of \tau, the target encoder slowly approximates the online encoder.This momentum-based update makes \xi evolve more slowly than \theta, which enables to bootstrap the representations by providing enhanced but consistent targets to the online encoders (Heet al., 2020b; Grill et al., 2020).Figure 1 illustrates the overall framework of BUIR with the simple one-hot encoders.
Bypassing the collapsed solution.  It is obvious that the loss in Equation (3) admits the collapsed solution with respect to \theta and \xi, which means both the encoders generate the same representations for all users and items.For this reason, the conventional end-to-end learning strategy, which optimizes both f_{\theta} and f_{\xi} to minimize the loss (i.e., cross-prediction error), may easily lead to such collapsed solution.In contrast, our proposed framework updates each of the encoders in different ways.From Equation (4), the online encoder is optimized to minimize the loss, while the target encoder is updated to slowly approximate the online encoder.That is, the direction of updating the target encoder (\theta-\xi) totally differs from that of updating the online encoder (-\nabla_{\theta}\mathcal{L}_{\theta,\xi}),and this effectively keeps both the encoders from converging to the collapsed solution.Several recent work on bootstrapping-based representation learning (Grill et al., 2020; Chen and He, 2021) empirically demonstrated that this kind of dynamics (i.e., updating two networks differently) allows to avoid the collapsed solution without any explicit term to prevent it.
Similarly to Section 3.2, the online encoder is trained by minimizing \mathcal{L}_{\theta,\xi}(\psi(u,\mathcal{V}_{u}),\psi(v,\mathcal{U}_{v})), and the target encoder is slowly updated by the momentum mechanism.After the optimization is finished, the interaction score is inferred by f_{\theta}(u,\mathcal{V}_{u}) and f_{\theta}(v,\mathcal{U}_{v}) (Equation (5)).Figure 2 shows an example of our data augmentation which injects a certain level of perturbations to the neighbors.","The online encoder is updated to minimize the error between its output and the target, while the target encoder is updated based on the momentum update.",0.7083333284722222,0.5396825350466112,0.7083333284722222,38.29629149616992,73.37018975625756,72.67142179265112,0.433261265361857,0.010717230008244,0.904643416404724,0.9560570071258908,0.9046433568000792,0.7089532613754272,0.3315248783262454,0.4085827171802521,4,1.0,4.0,1.0,0.96687810369535,0.7415739728159751,0.9662958912639008,0.9,0.4085827171802521
63,63,Why does assumning unobserved user-item pairs negative leads to limited performance for generative methods?,"Assuming unobserved user-item pairs negative leads to limited performance since there are some cases of positive but unobserved, and the number of this case is increased.","Nevertheless, the negative sampling approach has critical limitations in the following aspects.First, the underlying assumption about negative interactions becomes less valid as user-item interactions get sparser.This is because as fewer positive interactions are observed, the number of ”positive but unobserved” interactions increases, which consequently makes it even harder to sample correct negative ones.Such uncertainty of supervision eventually degrades the performance for top-K recommendation.Second, the convergence speed and the final performance depend on the specific choice of distributions for negative sampling.For example, sampling negative pairs from a non-uniform distribution (Rendle andFreudenthaler, 2014; Dinget al., 2019) (e.g., the multinomial distribution which models the probability of each interaction being actually negative) can improve the final performance, but inevitably incurs high computational costs, especially when a lot of users and items should be considered.","Increased uncertainty of supervision due to ""positive but unobserved"" interactions.",0.1714285673469388,0.0,0.1142857102040817,5.911245883122323,40.66558475194284,36.86429670780871,0.216018482864844,0.0041493775933609,0.3684728443622589,0.5307959480719131,0.3684728145599365,0.7369136810302734,0.0311657654113375,0.2580196261405945,4,1.0,4.0,0.0,0.8599861395489982,0.5887812889668773,0.855125155867509,0.8,0.2580196261405945
64,64,How did previous OCCF studies mitigated the problem of performance being largely depend on negative sampling distribution?,Previous OCCF studies assume that all unobserved interactions are negative to mitigate the problem of performance being largely depend on negative sampling distribution,"However, since the negative interactions are not available in the OCCF problem, previous discriminative methods assume that all unobserved interactions are negative.In other words, for each user, the items that have not been interacted yet are regarded to be less preferred to positive items.In this sense, they either use all unobserved user-item interactions as negative or adopt a negative sampling, which randomly samples unobserved user-item interactions in a stochastic manner to alleviate the computational burden.For better recommendation performance and faster convergence, advanced negative sampling strategies (Rendle andFreudenthaler, 2014; Dinget al., 2019) are also proposed to sample from non-uniform distributions.",They adopted advanced negative sampling strategies.,0.142857139489796,0.0740740710562415,0.142857139489796,3.2933284838220014,33.69210248423056,29.083208858823483,0.0876168224299065,0.0028490028490028,0.5546985864639282,0.5216586451078283,0.5546985268592834,0.6154393553733826,0.0090749525344237,0.091848611831665,3,1.0,2.0,1.0,0.8726129108088211,0.5839572630975373,0.8358134852738976,0.8,0.091848611831665
65,65,How does the negative pairs prevent the problem of collapsed solution during optimization in contrastive learning methods?,"To prevent the problem of collapsed sollution, they update target encoder and online encoder differently.","Pointing out that the contrastive methods need to carefully treat the negative instances during the training for effectiveness and efficiency, the most recent work proposed a bootstrapping-based self-supervised learning framework (Grill et al., 2020; Chen and He, 2021), which is capable of avoiding the collapsed solution without the help of negative instances.Inspired by bootstrapping methods in deep reinforcement learning (Mnihet al., 2015; Mnih et al., 2016), it directly bootstraps the representation of images by using two neural networks that iteratively learn from each other.This approach achieves the state-of-the-art performance for various downstream tasks in computer vision, and also shows better robustness to the choice of data augmentations used for self-supervision.
Bypassing the collapsed solution.  It is obvious that the loss in Equation (3) admits the collapsed solution with respect to \theta and \xi, which means both the encoders generate the same representations for all users and items.For this reason, the conventional end-to-end learning strategy, which optimizes both f_{\theta} and f_{\xi} to minimize the loss (i.e., cross-prediction error), may easily lead to such collapsed solution.In contrast, our proposed framework updates each of the encoders in different ways.From Equation (4), the online encoder is optimized to minimize the loss, while the target encoder is updated to slowly approximate the online encoder.That is, the direction of updating the target encoder (\theta-\xi) totally differs from that of updating the online encoder (-\nabla_{\theta}\mathcal{L}_{\theta,\xi}),and this effectively keeps both the encoders from converging to the collapsed solution.Several recent work on bootstrapping-based representation learning (Grill et al., 2020; Chen and He, 2021) empirically demonstrated that this kind of dynamics (i.e., updating two networks differently) allows to avoid the collapsed solution without any explicit term to prevent it.",They do not.,0.0,0.0,0.0,2.2869567780619007,10.395151905512773,9.918927068950593,0.0636942675159235,0.0021382751247327,0.120264820754528,0.0,0.1202648058533668,,0.0089185819391025,0.100280649960041,1,0.0,0.0,1.0,0.7917499138956909,0.1881594125899207,0.752637650359683,0.0,0.100280649960041
66,66,"How does the authors show utilizing augmented views of positive interactions can lead the performance improvement, especially in sparser datasets?","They show augmented views of positive interactions can lead the performance improvement, especially in sparser datasets by showing the experimental result of stochastic data augmentation achieved a big improvement compared to the case of using the fixed neighborhood information as encoder inputs.","In Figure 4, our stochastic data augmentation (i.e., P>0) brings a significant improvement compared to the case of using the fixed neighborhood information (i.e., P=0) as encoder inputs.This result shows that the augmented views of positive interactions encourage BUIR to effectively learn users’ preference on items even in much sparse dataset.Interestingly, in case of the Ciao dataset which is less sparse than CiteULike, the benefit of our augmentation linearly increases with the maximum drop probability.This is because there is room for producing more various views (i.e., larger perturbation) based on a relatively more number of neighbors, and it eventually helps to boost the recommendation performance.To sum up, our framework that adopts the neighbor augmentation function successfully relieves the data sparsity issue of the OCCF problem, by leveraging the augmented views of few positive interactions.
Our extensive evaluation on real-world implicit feedback datasets shows that BUIR consistently performs the best for top-K recommendation among a wide range of OCCF methods.In particular, the performance improvement becomes more significant in sparser datasets, with the help of utilizing augmented views of positive interactions as well as eliminating the effect of uncertain negative interactions.In addition, comparison results on a downstream task, which classifies the items into their category, support that BUIR learns more effective representations than other OCCF baselines.",By comparing the performance of BUIR with and without stochastic data augmentation in Figure 4.,0.2692307651257397,0.1090909052958679,0.2307692266642012,4.380833441723301,42.11695093552058,38.066054046802286,0.1805825242718446,0.0040376850605652,0.5110381245613098,0.6026490290959676,0.5110381245613098,0.4298222064971924,0.0371835982665657,0.2302341610193252,4,1.0,2.0,1.0,0.7842428634523158,0.5864739389537332,0.8458957558149328,0.8,0.2302341610193252
67,67,Does utilizing the multi-hop neighbor information in meta-graph help improve the performance of the proposed model?,"Through experiments, the authors demonstrated that the performance of the model (i.e., MRR@10) decreased without knowledge propagation and that it was comparable to vanilla ERNIE, which demonstrated that multi-hop neighbors were essential for ranking performance. This result can be attributed to how using multi-hope neighbors allows for knowledge to propagate between query and passage.","Knowledge propagation via meta-graph.It is worth noting that, the above-defined knowledge injection process only leverages knowledge embeddings learned by TransE on the global graph \overline{\mathcal{G}}. Particularly, it lacks considering the knowledge that bridges the semantics between query and passage. To this end, we introduce a Graph Meta Network (GMN) module that refines knowledge with the constructed meta-graph \mathbf{G}_{\mathbf{q},\mathbf{p}}, The multi-hop paths of \mathbf{G}_{\mathbf{q},\mathbf{p}} allow the knowledge to be propagated between query and passage, which can enhance the relevance signal to be captured by the model, and thus alleviate the semantic gap.
By applying a K-layer GMN in each layer of the knowledge injector, the output entity representation \hat{\mathbf{E}}_{e_{h}}^{(K)} can ensemble knowledge from all the K-hop neighbors. As described in Section 4.1.2 that all the paths of \mathbf{G}_{\mathbf{q},\mathbf{p}} between \mathbf{q} and \mathbf{p} is within K hops, the GMN module can attentively propagate knowledge along the paths from entities in \mathbf{p} to those in \mathbf{q}, and vice versa, which can enrich the semantics of the entities that benefit the relevance modeling.
Table 3 shows the performance comparisons between different settings of knowledge injector, which is statistically significant. From this table, we can observe the following phenomena. (1) MRR@10 of KERM without interaction and propagation process decreases at least 1\% respectively. This indicates both knowledge interaction and propagation processes play an indispensable role in ranking performance. (2) The performance of KERM without propagation is comparable to vanilla ERNIE. Not only query and passage entities, but also their multi-hop neighbors are essential for the ranking performance. (3) MRR@10 of KERM without knowledge interaction drops the most. It suggests the simple and straightforward way to aggregate knowledge graph with text does not work in the passage re-ranking scenario. The text and knowledge graph need to be refined with each other mutually in the interaction, which will be further analyzed in detail as follows.",Yes.,0.0,0.0,0.0,0.5482271666382152,1.430538747097935,2.223887476846551,0.0087873462214411,0.0001851508979818,0.0864363983273506,0.3005533218383789,0.085085816681385,,0.0055005033734424,0.0496411845088005,3,0.0,1.0,,0.8724785161886923,0.9367752902032774,0.7471011608131098,0.9,0.0496411845088005
68,68,What components of the proposed method aggregate explicit knowledge into implicit knowledge for query and passage embedding?,"This work proposes an aggregation module that employs a PLM and a Graph Neural Network (GMN) to model the interaction between explicit and implicit knowledge. The PLM encodes text to obtain word representations (i.e., implicit knowledge), and the Graph Neural Network (GMN) encodes knowledge meta-graphs to obtain entity representations (i.e., explicit knowledge). This module aggregates the word and entity representations to aggregate the implicit and explicit knowledge.","Knowledge propagation via meta-graph.It is worth noting that, the above-defined knowledge injection process only leverages knowledge embeddings learned by TransE on the global graph \overline{\mathcal{G}}. Particularly, it lacks considering the knowledge that bridges the semantics between query and passage. To this end, we introduce a Graph Meta Network (GMN) module that refines knowledge with the constructed meta-graph \mathbf{G}_{\mathbf{q},\mathbf{p}}, The multi-hop paths of \mathbf{G}_{\mathbf{q},\mathbf{p}} allow the knowledge to be propagated between query and passage, which can enhance the relevance signal to be captured by the model, and thus alleviate the semantic gap.
For knowledge aggregation, we design a novel interaction module between text and knowledge graph to combine the implicit and explicit knowledge. To derive implicit knowledge from text, we employ PLM as text encoder. To be aligned with implicit knowledge, knowledge meta graph is encoded with a multi-layer graph neural network (i.e. k-hop), namely Graph Meta Network (GMN). Each transformer layer outputs word representations. Each graph meta network layer outputs entity representations. Both word and entity representations are aggregated as the input of the following transformer and GMN layer, respectively in a novelly designed module, namely knowledge injector. Therefore through knowledge aggregation, implicit knowledge from text corpus and explicit knowledge from existing knowledge graph can mutually boost each other to achieve a better re-ranking performance, in which the issues in Challenge 2. could be mitigated.
Overall, our contributions can be summarized as follows:•It is the first attempt to solve the knowledge enhanced PLMs problem for passage re-ranking. The key motivation lies in that bridging the semantic gap between the query and passage with the help of both kinds of knowledge.•We design a novel knowledge graph distillation method. It refines a reliable knowledge graph from the existing one globally and constructs a knowledge meta graph based on the refined graph locally.•We propose a novel aggregation of PLM and graph neural network framework to model the interaction between explicit knowledge and implicit knowledge.•Experimental results show the effectiveness of KERM on both general and domain specific data, achieving state-of-the-art performance for passage re-ranking. We also conduct a comprehensive study for the effects of each module in our method. The code is available at https://github.com/DQ0408 /KERM.",Graph Meta Network (GMN) and knowledge injector.,0.2222222195950617,0.0294117630968859,0.2222222195950617,3.0787989546755594,20.463045776603103,20.492041042306514,0.054127198917456,0.0011277589817947,0.5523394346237183,0.7800568228618043,0.6186286807060242,0.7947155237197876,0.0129248096436994,0.2593919336795807,3,1.0,2.0,1.0,0.7774750525124533,0.4642162207276816,0.8568648829107265,0.8,0.2593919336795807
69,69,Does the paper show how each component of KERM can contribute to passage re-ranking performance quantitatively and qualitatively?,"This work conducted ablation studies to investigate the contribution of each component in the performance of KERM. By testing different settings for the knowledge injector, this work found that performance decreases without knowledge interaction and also without knowledge propagation. By testing the model without global or local distillation, they also demonstrated that performance decreases without global distillation and efficiency decreases without either global or local distillation. These experiments demonstrate that each component of KERM contributes to passage re-ranking performance quantitatively.","Here we compare ranking performances of KERM and other PLMs based re-rankers on the first two widely used query sets. Moreover, ablation studies for each component of KERM are also explored. All experimental results were reported under the same BM25 setting.
Table 3 shows the performance comparisons between different settings of knowledge injector, which is statistically significant. From this table, we can observe the following phenomena. (1) MRR@10 of KERM without interaction and propagation process decreases at least 1\% respectively. This indicates both knowledge interaction and propagation processes play an indispensable role in ranking performance. (2) The performance of KERM without propagation is comparable to vanilla ERNIE. Not only query and passage entities, but also their multi-hop neighbors are essential for the ranking performance. (3) MRR@10 of KERM without knowledge interaction drops the most. It suggests the simple and straightforward way to aggregate knowledge graph with text does not work in the passage re-ranking scenario. The text and knowledge graph need to be refined with each other mutually in the interaction, which will be further analyzed in detail as follows.
Knowledge graph distillation is performed in both global and local perspectives. To explore their roles in the ranking performance, we remove the graph pruning globally and sentence selection locally respectively, keep other settings unchanged, and derive KERM without graph pruning and sentence selection respectively. From results on TREC 2019 DL in Table 5, observations are listed as below. (1) Without global graph pruning, MRR@10 and the average edge score, calculated through Eq.(3), decrease the most, and the time efficiency drops slightly. This indicates the original knowledge graph exists noise data that affect performance. (2) Without sentence selection, the time efficiency drops the most and the average edge score decreases slightly, which proves that not every sentence in a passage has a positive effect on semantic matching. Overall, knowledge graph distillation is significant to KERM.",Yes.,0.0,0.0,0.0,0.4184430101881885,0.9132105204808338,1.5211392136726314,0.0064432989690721,0.0001249843769528,-0.0304322596639394,0.322697252035141,0.0588713586330413,,0.0038251509784079,0.0509391725063324,3,0.0,0.0,,0.851307069150541,0.8511666830551962,0.7380000655541181,0.0,0.0509391725063324
70,70,Does the author showed that the distillation on the knowledge graph can be useful for re-ranking task?,"This work proposes using knowledge graph distillation as it can help retain only informative knowledge needed for passage re-ranking. By investigating the effect of global and local distillation separately, this work found that the MRR@10 score and efficiency decreased slightly without global distillation, and that time efficiency decreased the most without local distillation. Therefore, this work demonstrates that both global and local distillation of knowledge graphs is useful for re-ranking tasks in terms of performance and efficiency.","Existing knowledge graphs are usually incomplete and noisy. It is unsuitable for direct introduction of them to the current model. Specially, there is no knowledge base particularly for passage re-ranking task. For example, ConceptNet (Speeret al., 2017) is a general knowledge graph that contains common sense knowledge, where the information might not be useful for our passage re-ranking task. Therefore, it is critical for us to propose a knowledge graph distillation process from both global and local perspectives.
Knowledge graph distillation is performed in both global and local perspectives. To explore their roles in the ranking performance, we remove the graph pruning globally and sentence selection locally respectively, keep other settings unchanged, and derive KERM without graph pruning and sentence selection respectively. From results on TREC 2019 DL in Table 5, observations are listed as below. (1) Without global graph pruning, MRR@10 and the average edge score, calculated through Eq.(3), decrease the most, and the time efficiency drops slightly. This indicates the original knowledge graph exists noise data that affect performance. (2) Without sentence selection, the time efficiency drops the most and the average edge score decreases slightly, which proves that not every sentence in a passage has a positive effect on semantic matching. Overall, knowledge graph distillation is significant to KERM.
The main goal of this paper is to reasonably introduce external knowledge graph to PLMs for passage re-ranking. We first design a novel knowledge meta graph construction method to distill reliable and query related knowledge from a general and noisy knowledge graph. The knowledge meta graph bridges the semantic gap between each query and passage. Then we propose a knowledge injector layer for mutually updating text and knowledge representations, which transformers word to entity representations for graph meta network, vice versa. Knowledge Enhanced Ranking Model is pretrained with Masked Language Model (MLM) Sentence Relation Prediction (SRP) [38] tasks, and fine-tuned with cross entropy loss function for passage re-ranking task. Experimental results on public benchmark datasets show the effectiveness of the proposed method compared with state-of-the-art baselines without external knowledge due to its first attempt. The role of each module in KERM is also comprehensively analyzed. Since this work was limited to the one-to-one meta-graph of a query-passage pair built online, continued efforts are needed to make knowledge enhancement more efficient for both retrieval and re-ranking stage.
Despite that the knowledge graph distillation in our method is empirically shown to be effective for the final performance, the implementation of graph pruning and meta-graph construction is still based on simple heuristics. A more promising way of formulating a useful meta-graph is to jointly learn a graph generator with the reranker in an end-to-end fashion, which enables more flexibility.Besides, it is currently infeasible to exploit the external knowledge in the retrieval stage, which needs to exhaustively build massive meta-graphs for a large scale of candidates. A further study could focus on how to use external knowledge in PLM based retriever.
For knowledge graph distillation, we propose a novel pipeline to establish knowledge meta graphs, which only retain informative knowledge for passage re-ranking. Specifically, we first distill a graph globally for passage re-ranking scenario from an existing knowledge graph by pruning some unreliable or noisy relations based on TransE embedding. Then for a specific query-passage pair, we extract entities from both the query and passage, and construct a query-document bipartite entity graph based on query and passage entities and their k-hop neighbors, namely knowledge meta graph. Challenge 1. could be addressed in this distillation process.",Yes.,0.0,0.0,0.0,0.423455197103223,1.0362289913816043,1.6317303067265416,0.0065189048239895,0.0001298532658096,0.0303853526711463,0.4011005461215973,0.055744744837284,,0.0074357567247238,0.050837006419897,3,0.0,0.0,1.0,0.0,0.5580745949914327,0.7323401492431147,0.0,0.050837006419897
71,71,Who collected the queries from MSMARCO-Passage dataset to make MSMARCO-TRAIN query set?,MARCO-Passage collection is a large-scale publicly available corpus and two query sets derived from this corpus are used in the paper: MSMARCO-TRAIN and MSMARCO-DEV. How and who collected the queries from MARCO-Passage to construct MSMARCO-TRAIN cannot be answered from this paper.,"We use a large-scale public available corpus, i.e., MSMARCO-Passage collection (Nguyen et al., 2016), as our passage collection. This collection contains approximately 8.8 million passages extracted from 3.2 million web documents covering multiple fields. We train our model on the MSMARCO-TRAIN query set of 502,939 queries and evaluate KERM on three query sets. Table 1 provides the detailed information of these query sets.The first test set is MSMARCO-DEV, which includes 6,980 sparsely-judged queries mixed with multiple domains. Each query has an average of 1.1 relevant passages with binary relevance label.The second test set is TREC 2019 DL (Craswell et al., 2020), which contains 43 densely-judged queries with fine-grained relevance labels, i.e., irrelevant, relevant, highly relevant and perfectly relevant. On average, a query has 95.4 relevant passages, and most queries have more than 10 relevant passages. With fine-grained labels and multiple relevant passages per query, TREC 2019 DL can be used to reflect the fine-grained ranking performance between relevant passages.To evaluate KERM on specific domains, we further introduce Ohsumed 111http://disi.unitn.it/moschitti/corpora.htm query set, which contains 63 queries on bio-medical domain.The collection of Ohsumed is constructed from the first 20,000 passages in Mesh categories of the year 1991.Following the previous work (Joachims, 1998), the test collection including 10,000 passages are utilized for performance comparison on Ohsumed query set.Each query has an average of 50.9 relevant passages with three graded relevance labels. In section 6.4, we demonstrate that the quality of external knowledge constructed by KERM in such domain could be more useful.",The answer is Nguyen et al.,0.0526315762880887,0.0,0.0526315762880887,0.9896324688555468,12.398854086525176,11.146301065957582,0.0485436893203883,0.001497753369945,0.0935186967253685,0.3606865911611489,0.1339326798915863,0.3598769307136535,0.0203435397459578,0.0999206826090812,1,1.0,0.0,0.0,0.8625037660422308,0.6886985228866641,0.7547940915466564,0.0,0.0999206826090812
72,72,What methods refine the graph containing external knowledge in 1) global and 2) local way?,"The knowledge graph is distilled globally by taking an existing knowledge graph and pruning unreliable or noise relations based on TransE embeddings. The graph is then distilled locally by extracting entities from both the given query and passage, and constructing a query-document bipartite entity graph based on the extracted entities and their k-hop neighbors.","For knowledge graph distillation, we propose a novel pipeline to establish knowledge meta graphs, which only retain informative knowledge for passage re-ranking. Specifically, we first distill a graph globally for passage re-ranking scenario from an existing knowledge graph by pruning some unreliable or noisy relations based on TransE embedding. Then for a specific query-passage pair, we extract entities from both the query and passage, and construct a query-document bipartite entity graph based on query and passage entities and their k-hop neighbors, namely knowledge meta graph. Challenge 1. could be addressed in this distillation process.","1) Pruning based on TransE embedding (global)
2) Constructing a query-document bipartite entity graph (local)",0.2962962922839506,0.1874999965820313,0.2962962922839506,7.977705003428323,53.436764165344776,46.77758043336194,0.2314784034749462,0.0033975084937712,0.7273355722427368,0.8139740507144713,0.747704803943634,0.7838099002838135,0.0756014601250743,0.234621375799179,4,1.0,5.0,1.0,0.8492225742581221,0.7255860747422163,0.9023442989688653,0.8,0.234621375799179
73,73,What is the example of unreliable relations in knowledge graph for passage re-ranking scenario?,"Unreliable relations in a knowledge graph involve trivial factual triplets that do not bring substantial information gain. For example, in ConceptNet, the entity “hepatitis” has relations with both “infectious disease” and “adult”. To the concept “hepatitis”,  the concept “adults” is more general than “infectious disease” and thus the relationship between “hepatitis” and “infectious disease” is more reliable and informative.","•Challenge 1. Existing knowledge graph are not constructed for re-ranking task. They usually contain trivial factual triples, which can hardly bring information gain. The inappropriate selection of external knowledge could even jeopardize the re-ranker performance. How to utilize existing knowledge graph to re-ranking task is remain a challenge.•Challenge 2.The explicit knowledge and implicit knowledge are highly heterogeneous due to the different sources, which makes the aggregation of the two difficult.How to mutually refine each other and effectively aggregate explicit knowledge into implicit knowledge to alleviate the semantic gap between query and passage is still a challenge.
Fig. 2 shows a real case of our global graph pruning method on ConceptNet, i.e., a general knowledge graph. In this case, the entity hepatitis has various relations to disease, infectious disease, adult, etc. From the distance of nodes in Fig. 2, we can clearly observe that the knowledge hepatitis is an infectious disease is more reliable and informative than hepatitis is located at adult. To hepatitis, the concept adult is more general than infectious disease. This indicates that our pruning method can effectively eliminate less informative knowledge.",hepatitis is located at adult.,0.0416666648003473,0.0,0.0416666648003473,0.6622258249686733,12.896992190840608,11.099847120957143,0.0272108843537414,0.0008613264427217,0.3103902637958526,0.8645057552575235,0.7530769109725952,0.6530328392982483,0.0130940915498643,0.0856255292892456,3,0.0,1.0,1.0,0.6874279898251374,0.831115797493839,0.7525665964620316,0.9,0.0856255292892456
74,74,"What does ""meta"" means in the term graph meta network (GMN)?",The Graph Meta Network (GMN) refines knowledge in a meta-graph. A meta-graph is a graph that is constructed by constructing multi-hop paths between the entities in a query and a passage using the knowledge from a global graph. The meaning for “meta” in both graph meta network (GMN) and meta-graph is not explicitly defined in this paper.,"Knowledge propagation via meta-graph.It is worth noting that, the above-defined knowledge injection process only leverages knowledge embeddings learned by TransE on the global graph \overline{\mathcal{G}}. Particularly, it lacks considering the knowledge that bridges the semantics between query and passage. To this end, we introduce a Graph Meta Network (GMN) module that refines knowledge with the constructed meta-graph \mathbf{G}_{\mathbf{q},\mathbf{p}}, The multi-hop paths of \mathbf{G}_{\mathbf{q},\mathbf{p}} allow the knowledge to be propagated between query and passage, which can enhance the relevance signal to be captured by the model, and thus alleviate the semantic gap.
For knowledge aggregation, we design a novel interaction module between text and knowledge graph to combine the implicit and explicit knowledge. To derive implicit knowledge from text, we employ PLM as text encoder. To be aligned with implicit knowledge, knowledge meta graph is encoded with a multi-layer graph neural network (i.e. k-hop), namely Graph Meta Network (GMN). Each transformer layer outputs word representations. Each graph meta network layer outputs entity representations. Both word and entity representations are aggregated as the input of the following transformer and GMN layer, respectively in a novelly designed module, namely knowledge injector. Therefore through knowledge aggregation, implicit knowledge from text corpus and explicit knowledge from existing knowledge graph can mutually boost each other to achieve a better re-ranking performance, in which the issues in Challenge 2. could be mitigated.
Different from existing knowledge-enhanced PLMs for other NLP tasks, our aim for the re-ranking task is particularly on the relevance modeling between query and passage. Thus, we further leverage the knowledge in the global graph G to construct “bridges” between query and passage, which alleviates the semantic gap and improves semantic modeling. More specifically, for a given query-passage pair (i.e., (q, p)), we propose to construct a bipartite meta-graph that connects those entities in the q and those in p.","""meta"" refers to the meta-graph.",0.0909090888946281,0.0,0.0454545434400827,1.3456496076279458,18.594748371638502,16.77744813970146,0.0332225913621262,0.0008920606601248,0.7473383545875549,0.4089467134968987,0.8511633276939392,0.2712909579277038,0.0490302454668029,0.3057580590248108,3,1.0,2.0,1.0,0.8681643599673586,0.5931680623826305,0.8726722495305219,0.0,0.3057580590248108
75,75,What is the other example of frameworks that can be used in PaddlePaddle like Paddle Graph Learning?,This work mentions using the Paddle Graph Learning (PGL) framework from the deep learning framework PaddlePaddle. Other examples of frameworks in PaddlePaddle are not mentioned in this paper.,"We use the traditional sparse retriever BM25 (Yanget al., 2017) as our first stage method. All experiments are conducted under the same BM25 setting with 1000 retrieved candidates. We conduct experiments with the deep learning framework PaddlePaddle (Maet al., 2019) on up to 4 NVIDIA Tesla A100 GPUs (with 40G RAM). For the GMN module, we use Paddle Graph Learning (PGL) 222https://github.com/PaddlePaddle/PGL, an efficient and flexible graph learning framework based on PaddlePaddle. For training, we used the Adam optimizer (Kingma and Ba, 2014) with a learning rate of 1e-5 for text encoder and 1e-4 for knowledge injector. The model is trained up to 5 epochs with a batch size of 640 and 240 for base and large models respectively.In our experiments, the PLM small, base and large models have 6, 12 and 24 Transformer layers respectively.The text encoder has 9 layers and 21 layers for base and large model respectively, and the knowledge injector both has 3 layers in our experiment. The dropout rates are set to 0.1. The ratio of the positive to the hard negative is set to 1:19.All transformer layers in KERM’s backbone are initialized from ERNIE-2.0 base (Sunet al., 2020b), which is a BERT-like model pre-trained with a continual pre-training framework on multiple tasks. We perform Knowledge-enhanced pre-training on MARCO passage collection to warm up the parameters in knowledge injector, which has 60,000 iterations under the batch size of 256.For a fair comparison, the same pre-training without knowledge enhancement is also conducted on \textrm{ERNIE}_{\textrm{base}} re-ranker and all models in ablation studies.",PaddlePaddle itself.,0.0769230755029586,0.0,0.0769230755029586,1.3794462224541233,23.2407094240314,20.34023472937097,0.0343642611683848,0.000740192450037,0.6137433052062988,0.0,0.7313864231109619,,0.0445148146667569,0.4644789695739746,2,1.0,0.0,1.0,0.8669532003063319,0.5756178474986489,0.8024713899945954,0.5,0.4644789695739746
76,76,How many entities and relations does ConceptNet has?,"ConceptNet is a general knowledge graph and, in this work, they merged relation types in the graph to construct a multi-relational graph with 17 relation types. The full number of entities and relations that are found in ConceptNet cannot be answered in this paper.","We use ConceptNet (Speeret al., 2017), a general knowledge graph as our external knowledge base \mathcal{G}. Following KagNet (Linet al., 2019), we merge relation types to increase graph density and construct a multi-relational graph with 17 relation types, including atlocation, causes, createdby, etc.",Not specified.,0.0,0.0,0.0,0.7605497822189857,5.503681421614624,5.170388338339047,0.0225225225225225,0.0004543389368468,0.0986801087856292,0.2100986766404119,0.2171776741743087,,0.0043515696230689,0.0579428523778915,1,0.0,0.0,,0.0,0.1887835572587863,0.7551342290351455,0.0,0.0579428523778915
77,77,How is next sentence prediction (NSP) different from sentence relation prediction (SRP)?,"Compared to conventional Next Sentence Prediction (NSP), Sentence Relation Prediction (SRP) aims to predict whether a given sentence is the next sentence, previous sentence relation, or no relation with another sentence.","Knowledge-enhanced pre-training.Following previous studies (Nogueiraet al., 2019a; Yanet al., 2021; Kim and Ko, 2021), we conduct continual pre-training on MSMARCO corpus to warm up the parameters of GMN module.We apply Masked Language Model (MLM) (Devlinet al., 2018) and Sentence Relation Prediction (SRP) (Wang et al., 2019) as the pre-training tasks in KERM.Compared to conventional Next Sentence Prediction (NSP) (Devlinet al., 2018), the task of SRP is to predict whether a given sentence is the next sentence, previous sentence relation or no relation with another sentence. To incorporate knowledge during the pre-training stage, we construct a meta-graph for each sentence pair, and apply the knowledge aggregation process as introduced above.The pre-training loss is defined as\mathcal{L}_{p}=\mathcal{L}_{MLM}+\mathcal{L}_{SRP}.","NSP predicts the next sentence, while SRP predicts the relation (next, previous, or no relation).",0.3076923032478633,0.1395348795024338,0.256410251965812,14.59616940826799,51.74450423764867,48.51834428458508,0.3850936764662079,0.005736137667304,0.867103636264801,0.954703648557368,0.8671035766601562,0.7384409308433533,0.1181036606350716,0.8619132041931152,4,0.5,4.0,0.5,0.8878940579046857,0.8376817089286305,0.9507268357145214,0.8,0.8619132041931152
78,78,How is DPR retriever different from BM25?,BM25 and DPR are both examples of retrievers used in large-scale passage collection. BM25 is described as a traditional sparse retriever and DPR leverages PLM to empower the retriever by a single vector. How both BM25 and DPR function is not described in detail in this paper and thus their differences cannot be answered in this paper.,"The low-dimensional dense representations for query and passage are computed by PLMs based retrievers from the dual-encoder architecture. Afterward, the candidate passage set could be retrieved efficiently via approximate nearest neighbor algorithms.Existing studies could be categorized into two parts:(1) By optimizing the matching stage: DPR (Karpukhin et al., 2020) is the first study to leverage PLM to empower the retriever by a single vector. Other researches, such asRepBERT (Zhanet al., 2020), ColBERT (Khattab andZaharia, 2020), COIL (Gaoet al., 2021) and Interactor (Yeet al., 2022), obtain multiple vectors for query and passage for matching.(2) By optimizing the representation learning module: RocketQAv1 (Qu et al., 2021) and RocketQAv2 (Ren et al., 2021) boost the representation learning of retriever by leveraging the power of cross-encoder in a cascade or joint manner. Other studies boost the representation learning by designed IR-oriented pre-training tasks.ICT (Leeet al., 2019) treats sentences as pseudo-queries and matched them to the passage they originate from. Condenser (Gao and Callan, 2021) utilizes a novel pre-training task, which can produces an information-rich representation to condense an input sequence.
We use the traditional sparse retriever BM25 (Yanget al., 2017) as our first stage method. All experiments are conducted under the same BM25 setting with 1000 retrieved candidates. We conduct experiments with the deep learning framework PaddlePaddle (Maet al., 2019) on up to 4 NVIDIA Tesla A100 GPUs (with 40G RAM). For the GMN module, we use Paddle Graph Learning (PGL) 222https://github.com/PaddlePaddle/PGL, an efficient and flexible graph learning framework based on PaddlePaddle. For training, we used the Adam optimizer (Kingma and Ba, 2014) with a learning rate of 1e-5 for text encoder and 1e-4 for knowledge injector. The model is trained up to 5 epochs with a batch size of 640 and 240 for base and large models respectively.In our experiments, the PLM small, base and large models have 6, 12 and 24 Transformer layers respectively.The text encoder has 9 layers and 21 layers for base and large model respectively, and the knowledge injector both has 3 layers in our experiment. The dropout rates are set to 0.1. The ratio of the positive to the hard negative is set to 1:19.All transformer layers in KERM’s backbone are initialized from ERNIE-2.0 base (Sunet al., 2020b), which is a BERT-like model pre-trained with a continual pre-training framework on multiple tasks. We perform Knowledge-enhanced pre-training on MARCO passage collection to warm up the parameters in knowledge injector, which has 60,000 iterations under the batch size of 256.For a fair comparison, the same pre-training without knowledge enhancement is also conducted on \textrm{ERNIE}_{\textrm{base}} re-ranker and all models in ablation studies.
Given a query q, passage re-ranking aims at ordering a set of 𝜘 passages, i.e., P =  p𝜅 	𝜘 𝜅=1 , which is usually retrieved from a large-scale passage collection by a retriever, e.g. BM25 [48], DPR [16] etc. In particular, a passage is a sequence of words p = {𝑤𝑝 } |p| 𝑝=1 , where |p| is the length of passage p. Similarly, a query is a sequence of words q = {𝑤𝑞 } |q| 𝑞=1 . Note that a passage p consists of 𝑇 sentences p = {s𝜏 } 𝑇 𝜏=1.","DPR uses a single vector for query and passage, whereas BM25 is a traditional sparse retriever.",0.3636363596694215,0.1818181783057851,0.218181814214876,6.686940155820416,43.79694587411765,41.9618120896254,0.1691681963790807,0.0031897926634768,0.8013198375701904,0.7478890947088548,0.8267553448677063,0.80011385679245,0.0966440665210505,0.4591326713562011,3,1.0,4.0,1.0,0.9526508878866248,0.5583387599255278,0.9000217063687779,0.8,0.4591326713562011
79,79,What is the difference of RocketQAv1 and RocketQAv2 model?,"RocketQAv1 trains dual-encoder and cross-encoder in a cascade manner, which leverages the powerful cross-encoder to empower the dual-encoder. While it inherits the parameters from RocketQAv1, RocketQAv2 extends the first version through a novel approach that jointly trains the dense passage retriever and passage re-ranker, and by using a large PLM for data augmentation and denoising (i.e.,  a distillation procedure).","Existing PLMs based re-rankers typically improve ranking performance from two aspects: (1) By optimizing the ranking procedure: monoBERT (Nogueira and Cho, 2019) is the first work that re-purposed BERT as a passage re-ranker and achieves state-of-the-art results. duoBERT (Nogueiraet al., 2019a) integrates monoBERT in a multistage ranking architecture and adopts a pairwise classification approach to passage relevance computation. UED (Yanet al., 2021) proposes a cascade pre-training manner that can jointly enhance the retrieval stage through passage expansion with a pre-trained query generator and thus elevate the re-ranking stage with a pre-trained transformer encoder. The two stages can facilitate each other in a unified pre-training framework. H-ERNIE (Chuet al., 2022) proposes a multi-granularity PLM for web search.(2) By designing rational distillation procedure: LM Distill + Fine-Tuning (Gaoet al., 2020) explores a variety of distillation methods to equip a smaller re-ranker with both general-purpose language modeling knowledge learned in pre-training and search- specific relevance modeling knowledge learned in fine-tuning, and produces a faster re-ranker with better ranking performance. CAKD (Hofstätter et al., 2020) proposes a cross-architecture knowledge distillation procedure with a Margin-MSE loss, which can distill knowledge from multiple teachers at the same time. RocketQAv1 (Qu et al., 2021) trains dual-encoder and cross-encoder in a cascade manner, which leverages the powerful cross-encoder to empower the dual-encoder. RocketQAv2 (Ren et al., 2021) proposes a novel approach that jointly trains the dense passage retriever and passage re-ranker. The parameters of RocketQAv2 are inherited from RocketQAv1. Besides, RocketQAv2 utilizes a large PLM for data augmentation and denoising, which can also be regarded as a distillation procedure. Notably, these two types of studies anticipate more insightful information to be captured by the advanced ranking and training procedures, while neglecting the limitations of implicit knowledge extracted from noisy and heterogeneous data. Therefore, in this paper, we proposed the first knowledge-enhanced PLM based re-ranker, which thoughtfully leverages explicit external knowledge that improve the effectiveness of the model.
We include several PLMs based re-rankers in our evaluation, including the state-of-the-art:•monoBERT (Nogueira and Cho, 2019): The first study that re-purposes BERT as a re-ranker and achieves state-of-the-art results.•duoBERT (Nogueiraet al., 2019a):This work proposes a pairwise classification approach using BERT, which obtains the ability to be more sensitive to semantics through greater computation.•UED (Yanet al., 2021): A unified pre-training framework that jointly refines re-ranker and query generator. For a fair comparison, we only use the re-ranker in UED without passage expansion.•LM Distill+Fine-Tuning (LDFT) (Gaoet al., 2020):A variety of distillation methods are compared in this paper. The experimental results indicate that a proper distillation procedure (i.e. first distill the language model, and then fine-tune on the ranking task) could produce a faster re-ranker with better ranking performance.•CAKD (Hofstätter et al., 2020): This work proposes a cross-architecture knowledge distillation procedure with Margin-MSE loss, which can distill knowledge from multiple teachers.•RocketQAv1 (Qu et al., 2021): This work mainly focuses on the training of PLM based retriever, where the re-ranker is an intermediate product of its training process.•RocketQAv2 (Ren et al., 2021): Based on RocketQAv1, this work proposes a novel approach that jointly trains the PLM based retriever and re-ranker.To compare the performance of different methods, we resort to two ranking metrics.For MSMARCO-DEV, We adopt Mean Reciprocal Rank (i.e., MRR@10).For TREC 2019 DL, we use Mean Average Precision, i.e., MAP@10 and MAP@30.For Ohsumed, both Mean Reciprocal Rank and Mean Average Precision (i.e., MRR@10 and MAP@10) are employed for comprehensive performance analysis in queries requiring in-depth domain knowledge.","RocketQAv1 trains dual-encoder and cross-encoder in a cascade manner, while RocketQAv2 jointly trains the dense passage retriever and passage re-ranker.",0.4687499960986329,0.3797468317897773,0.4687499960986329,23.7160848423724,70.4817713817393,68.64209326772773,0.2962148760330578,0.0049751243781094,0.8549797534942627,0.6478190630048465,0.8437957167625427,0.7962425351142883,0.5631576103936853,0.1629813015460968,4,1.0,4.0,1.0,0.9791328821850048,0.4930115829682284,0.9720463318729138,1.0,0.1629813015460968
80,80,Would the performance be improved if the PLM model is pre-trained or fine-tuned on bio-medical domain datasets?,"In their experiments, the authors showed that all of the models performed poorly on the bio-medical domain due to the textual data of the domain not being covered widely in the PLMs’ pretraining dataset. This lack of data can cause the PLM to struggle to reveal and capture knowledge specific to that domain. These results suggest that further training on bio-medical data could increase performance.","However, implicit knowledge still has some inherent weaknesses, which limits the applicability of PLMs based re-rankers. First,queries and passages are usually created by different persons and have different expression ways (Nogueiraet al., 2019b), such as word usage and language style.Worse still, the data distributions of search queries and web contents are highly heterogeneous (Liuet al., 2021), where various specialized domains (e.g., bio-medical) may only have few training examples in a general corpus. Domain-specific knowledge can hardly be revealed and captured by the model, and thus the processing of domain-specific queries is often inaccurate.
Results are obtained from Table 6. (1) Poor ranking performances of all models on bio-medical domain indicates that it is more challenging in the data scarcity scenario, where textual data is not covered widely in the PLMs’ pretraining datasets. (2) Compared with ERNIE, KERM has a higher relative improvement in bio-medical domain than general domain. This demonstrates that the incorporation of knowledge graph is more useful for a data scarcity domain. To verify this idea, we compare the size of knowledge meta graph used for different domains as follows.",Yes.,0.0,0.0,0.0,0.5238546714708301,1.42645753472004,2.0629144198016047,0.0079113924050632,0.0001538224888478,0.0409947894513607,0.2800340354442596,0.043342687189579,,0.0023718737788956,0.0491567961871624,3,0.0,0.0,,0.7811983434751272,0.933789088454916,0.7352322707031379,0.8,0.0491567961871624
81,81,What characteristics of large-scale pre-trained language models made it remarkable successful for passage re-ranking task?,Large-scale pre-trained language models (PLMs) have been found to be successful for passage re-ranking due to their ability to learn semantic relevance in the latent space from massive textual corpus. PLMs obtain this ability from their expressive transformer architecture and the pretrain-then-finetune paradigm.,"Passage Re-ranking is a crucial stage in modern information retrieval systems, which aims to reorder a small set of candidate passages to be presented to users. To put the most relevant passages on top of a ranking list, a re-ranker is usually designed with powerful capacity in modeling semantic relevance, which attracted a wealth of research studies in the past decade (Guo et al., 2020). Recently,large-scale pre-trained language models (PLMs), e.g. BERT (Devlinet al., 2018), ERNIE (Sun et al., 2019) and RoBERTa (Liu et al., 2019), have dominated many natural language processing tasks, and have also achieved remarkable success on passage re-ranking.For example, PLM based re-rankers (MacAvaney et al., 2019; Liet al., 2020; Dong and Niu, 2021; Donget al., 2022) have achieved state-of-the-art performance, which takes the concatenation of query-passage pair as input, and applies multi-layer full-attention to model their semantic relevance. Their superiority can be attributed to the expressive transformer structure and the pretrain-then-finetune paradigm, which allow the model to learn useful implicit knowledge (i.e., semantic relevance in the latent space) from massive textual corpus (Fan et al., 2021).",Expressive transformer structure and pretrain-then-finetune paradigm.,0.186046509226609,0.0425531895880489,0.186046509226609,3.2874736544776946,50.9373249042716,44.50931291768976,0.1308139534883721,0.001576458223857,0.4208429753780365,0.7917739898560057,0.8272204995155334,0.569937527179718,0.2392931594159918,0.3507334589958191,4,1.0,4.0,1.0,0.8729702587778795,0.7155008717732958,0.8620034870931831,0.8,0.3507334589958191
82,82,How does the knowledge distilation works if meta-graph can't be constructed (i.e. there is no corresponding entities in knowledge graph for query/passage)?,"Entities that exactly match entities in E are selected from q and s* to construct the meta-graph. Also, entities that are sub-sequences of other recognized entities are omitted. This process assumes that entities are identified in the query and passage. The process for handling cases where no entities are identified cannot be answered in this paper.","(1)Key sentence selection. The actual information need of a user usually concentrates on a small part of a relevant passage (Guo et al., 2020). To this end, we mimic human judgment and only focus on the sentence of each passage that is the most related to a query (Zou et al., 2021).In particular, we define the relevance score between a query q and a sentence \textbf{s}_{i} as(7)Rel_{qs}(\textbf{q},\textbf{s}_{i})=\frac{\sum_{q=1}^{|\textbf{q}|}\textbf{E}(w_{q})}{|\textbf{q}|}\cdot\frac{\sum_{s=1}^{|\textbf{s}_{i}|}\textbf{E}(w_{s})}{|\textbf{s}_{i}|}.For the sake of efficiency, we initialize \textbf{E}(w) from Word2Vec (Mikolovet al., 2013) embedding.Based on Eq.(7), we select the most relevant sentence \textbf{s}^{*} in p to build the meta-graph for \mathbf{q} and \mathbf{p}.(2)Target entity recognition.Next, we select the entities in q and \textbf{s}^{*} to construct the meta-graph. Specifically, we only consider the entities that exactly match in \mathcal{E}. Meanwhile, we omit those entity phrases that are sub-sequences of other recognized entities.For example, in the query ""what causes low liver enzymes"", both ""liver"" and ""liver enzyme"" are entities, but the entity ""liver enzyme"" is more informative to be recognized as the target entity, and ""liver"" should be omitted.(3)Path discovery. Finally, given the target entities of q and \textbf{s}^{*} (denoted as \phi_{\mathbf{q}} and \phi_{\mathbf{s}^{*}}, respectively), we perform Breadth First Search (BFS) on \overline{\mathcal{G}} to discover the paths within K-hop between \phi_{\mathbf{q}} and \phi_{\mathbf{s}^{*}}. Note that we only keep the within-K-hop paths that might be the most useful for the downstream re-ranking task. Meanwhile, the knowledge could be complemented from the K-hop paths.",The knowledge distillation fails or uses a default method.,0.0408163235318619,0.0,0.0408163235318619,0.6950744244935309,13.5064598525078,11.355716339023028,0.0173310225303292,0.0016336903249228,0.0958279818296432,0.4325758537317397,0.1842022240161895,0.3962467610836029,0.0039211028997504,0.0536829307675361,3,0.0,1.0,0.5,0.0,0.4328543772716715,0.7314175090866859,0.7,0.0536829307675361
83,83,Does this method likely to show similar tendency of performance improvement when other backbone model (like BERT_large) is used?,"Through the experiments, this work demonstrated that the KERM model was able to significantly improve on the performance of its backbone model, ERNIE. The authors posit that this is due to how KERM explicitly introduces external knowledge which can improve semantic matching performance. This suggests that KERM models with other backbone models will be able to improve on the performance of their backbone models. However, the likelihood of performance improvements with other backbone models cannot be answered from this paper.","We use the traditional sparse retriever BM25 (Yanget al., 2017) as our first stage method. All experiments are conducted under the same BM25 setting with 1000 retrieved candidates. We conduct experiments with the deep learning framework PaddlePaddle (Maet al., 2019) on up to 4 NVIDIA Tesla A100 GPUs (with 40G RAM). For the GMN module, we use Paddle Graph Learning (PGL) 222https://github.com/PaddlePaddle/PGL, an efficient and flexible graph learning framework based on PaddlePaddle. For training, we used the Adam optimizer (Kingma and Ba, 2014) with a learning rate of 1e-5 for text encoder and 1e-4 for knowledge injector. The model is trained up to 5 epochs with a batch size of 640 and 240 for base and large models respectively.In our experiments, the PLM small, base and large models have 6, 12 and 24 Transformer layers respectively.The text encoder has 9 layers and 21 layers for base and large model respectively, and the knowledge injector both has 3 layers in our experiment. The dropout rates are set to 0.1. The ratio of the positive to the hard negative is set to 1:19.All transformer layers in KERM’s backbone are initialized from ERNIE-2.0 base (Sunet al., 2020b), which is a BERT-like model pre-trained with a continual pre-training framework on multiple tasks. We perform Knowledge-enhanced pre-training on MARCO passage collection to warm up the parameters in knowledge injector, which has 60,000 iterations under the batch size of 256.For a fair comparison, the same pre-training without knowledge enhancement is also conducted on \textrm{ERNIE}_{\textrm{base}} re-ranker and all models in ablation studies.
(4) Compared with \textrm{ERNIE}_{\textrm{base}} we trained, \textrm{KERM}_{\textrm{base}} shows a significant improvement on both two query sets. This indicates the explicit introduction of external knowledge can alleviate the semantic gap and heterogeneity between query and passage, and improve the semantic matching performance.",No.,0.0,0.0,0.0,0.4135480978530135,1.0822510822510825,1.732202894313697,0.0062972292191435,0.0001249843769528,0.1149081513285636,0.2869319021701813,0.0850676670670509,,0.0015703523929292,0.0591006912291049,1,0.0,0.0,0.0,0.8123927606702449,0.4790970419841756,0.716276535424656,0.0,0.0591006912291049
84,84,Why does existing knowledge enhanced PLMs (such as CokeBERT and CoLake) cannot be used directly for re-ranking tasks?,"While approaches like CokeBERT and CoLake integrate sophisticated knowledge into PLMs through knowledge graphs, they did not focus specifically on using knowledge to empower PLMs for re-ranking tasks. The reasons for why CokeBERT or CoLake cannot be directly used in re-ranking cannot be answered from this paper.","Existing KE-PLMs can be categorized by the granularity of knowledge they incorporate from knowledge graph (KG), as text-based knowledge, entity knowledge and KG meta-graphs.To integrate text-based knowledge, RAG (Lewiset al., 2020) and KIF (Fanet al., 2020) first retrieve top-k documents from Wikipedia using KNN-based retrieval, and the PLM model is employed to generate the output conditioned on these retrieved documents. Entity-level information can be highly useful for a variety of natural language understanding tasks. Hence, many existing KE-PLMs target this type of simple yet powerful knowledge. ERNIE(BAIDU) (Sun et al., 2019) introduces a new pre-training strategy of language model which masking phrases or entities in order to implicitly learn both synaptic and semantic knowledge from these units. ERNIE(THU) (Zhanget al., 2019) integrates informative entity representations in the knowledge module into the underlying layers of the semantic module based on the alignments between text and entity to equip the model with the ability of knowledge awareness. As knowledge graphs provide richer information than simply entity, more and more researchers start to explore integration of more sophisticated knowledge, such as meta-graphs in KG. CokeBERT (Su et al., 2021) proposes a novel semantic-driven Graph Neural Network (GNN) to dynamically select contextual knowledge and embed knowledge context according to textual context for PLMs, which can avoid the effect of redundant and ambiguous knowledge in KGs that cannot match the input text.CoLake (Sunet al., 2020a) also uses GNN to aggregate information from the constructed meta-graph in both pre-training and inference. CoLake converts the meta-graph into token sequence and appends it to input sequence for PLMs, which is distinctive to CokeBERT. Although extensive research has been proposed up to now to address the knowledge-aware problem, none exists which constrained on how to use knowledge to empower PLMs particularly for re-ranking tasks.
Different from existing knowledge-enhanced PLMs for other NLP tasks, our aim for the re-ranking task is particularly on the relevance modeling between query and passage.Thus, we further leverage the knowledge in the global graph \overline{\mathcal{G}} to construct “bridges” between query and passage, which alleviates the semantic gap and improves semantic modeling.More specifically, for a given query-passage pair (i.e., (\mathbf{q},\mathbf{p})), we propose to construct a bipartite meta-graph that connects those entities in the \mathbf{q} and those in \mathbf{p}.",They lack relevance modeling between query and passage.,0.0434782579962194,0.0,0.0434782579962194,0.8671339908544159,12.948845454697604,11.165144239967487,0.0314465408805031,0.0017361111111111,0.2730971574783325,0.4420288195635409,0.3820726573467254,0.5268107056617737,0.001324340616375,0.068078376352787,3,1.0,1.0,,0.8454165480423188,0.5041782370104122,0.8167129480416486,0.8,0.068078376352787
85,85,Would there be a performance gain if the model utilizes the IE (information extraction) model instead of the exact match for target entity recognition?,"This work’s approach aims at focusing mostly on informative factors. For example, the key sentence selection module focused on extracting only the most relevant sentences and the target entity recognition module focused on identifying only the most informative entities. Further, this work argues that, to use knowledge graphs for re-ranking tasks, it is important that the graphs contain triplets with substantial information gain. The effect on information gain from using IE models, instead of exact match, for target entity recognition cannot be answered from this paper.","(1)Key sentence selection. The actual information need of a user usually concentrates on a small part of a relevant passage (Guo et al., 2020). To this end, we mimic human judgment and only focus on the sentence of each passage that is the most related to a query (Zou et al., 2021).In particular, we define the relevance score between a query q and a sentence \textbf{s}_{i} as(7)Rel_{qs}(\textbf{q},\textbf{s}_{i})=\frac{\sum_{q=1}^{|\textbf{q}|}\textbf{E}(w_{q})}{|\textbf{q}|}\cdot\frac{\sum_{s=1}^{|\textbf{s}_{i}|}\textbf{E}(w_{s})}{|\textbf{s}_{i}|}.For the sake of efficiency, we initialize \textbf{E}(w) from Word2Vec (Mikolovet al., 2013) embedding.Based on Eq.(7), we select the most relevant sentence \textbf{s}^{*} in p to build the meta-graph for \mathbf{q} and \mathbf{p}.(2)Target entity recognition.Next, we select the entities in q and \textbf{s}^{*} to construct the meta-graph. Specifically, we only consider the entities that exactly match in \mathcal{E}. Meanwhile, we omit those entity phrases that are sub-sequences of other recognized entities.For example, in the query ""what causes low liver enzymes"", both ""liver"" and ""liver enzyme"" are entities, but the entity ""liver enzyme"" is more informative to be recognized as the target entity, and ""liver"" should be omitted.(3)Path discovery. Finally, given the target entities of q and \textbf{s}^{*} (denoted as \phi_{\mathbf{q}} and \phi_{\mathbf{s}^{*}}, respectively), we perform Breadth First Search (BFS) on \overline{\mathcal{G}} to discover the paths within K-hop between \phi_{\mathbf{q}} and \phi_{\mathbf{s}^{*}}. Note that we only keep the within-K-hop paths that might be the most useful for the downstream re-ranking task. Meanwhile, the knowledge could be complemented from the K-hop paths.
• Challenge 1. Existing knowledge graph are not constructed for re-ranking task. They usually contain trivial factual triples, which can hardly bring information gain. The inappropriate selection of external knowledge could even jeopardize the re-ranker performance. How to utilize existing knowledge graph to re-ranking task is remain a challenge. • Challenge 2. The explicit knowledge and implicit knowledge are highly heterogeneous due to the different sources, which makes the aggregation of the two difficult. How to mutually refine each other and effectively aggregate explicit knowledge into implicit knowledge to alleviate the semantic gap between query and passage is still a challenge.",Yes.,0.0,0.0,0.0,0.3741567601961751,1.4944587381498835,1.82148423092398,0.005599104143337,0.0001162655505173,0.0420343093574047,0.5115655064582825,0.0917206332087516,,0.005346262424487,0.0598342306911945,3,0.0,0.0,,0.8203016512916084,0.4368498558087217,0.7473994232348867,0.0,0.0598342306911945
86,86,How does TransE learns entity and relatio embeddings in unsupervised way?,TransE is an unsupervised learning method that learns latent representations for a knowledge triplet. The method in which TransE learns these latent representations cannot be answered from this paper.,"Given a global knowledge graph \mathcal{G}, the first step is to eliminate those knowledge that might be noisy to be applied. To achieve this, we use TransE (Bordes et al., 2013) to measure the reliability of a given knowledge triplet. In particular, TransE is an unsupervised learning method that learns latent representations for a knowledge triplet (e_{h},r,e_{t}). Intuitively, it models the latent distribution of knowledge in a given knowledge graph, and those who are out of this distribution can be viewed as less informative knowledge, which should not be used. Based on this,we use the entity embeddings pre-trained by TransE to calculate a distance metric between two linked entities as(3)Rel_{e}(e_{h},r,e_{t})=\mathbf{E}({e_{h}})\cdot\mathbf{E}(r)+\mathbf{E}({e_{h}})\cdot\mathbf{E}({e_{t}})+\mathbf{E}({r})\cdot\mathbf{E}({e_{t}}),(4)Dist(e_{h},e_{t})=\frac{1}{Rel_{e}(e_{h},r,e_{t})},where \mathbf{E}({e}) and \mathbf{E}({r}) are the TransE embeddings of entity and relation, respectively, and the inner product measures the relevance between two vectors. As the objective of TranE is aligned with minimizing the distance shown in Eq.(4), we can consider those knowledge triplets with small distance values as informative knowledge.",TransE learns entity and relation embeddings by minimizing the distance between entities and relations in the latent space.,0.1999999952000001,0.0454545407128104,0.1499999952000001,3.016200863100729,32.922394773556945,28.22516243807476,0.1388888888888889,0.0068754774637127,0.7382907271385193,0.5569101013492381,0.7369257211685181,0.6065303087234497,0.0145494553189158,0.3817850947380066,3,1.0,2.0,1.0,0.8754860815050097,0.5969951067086864,0.8879804268347454,0.8,0.3817850947380066
87,87,What is the maximum memory capacity of FPGA? ,"Near 10 MB of on-chip memory and no off-chip memory or storage(For example, the Xilinx Vertex-7 FPGA has a maximum of 8.5 MB (i.e. 68 Mbits) of on-chip memory and does not provide off-chip memory)","Much of the recent research on deep convolutional neural networks (CNNs) has focused on increasing accuracy on computer vision datasets.For a given accuracy level, there typically exist multiple CNN architectures that achieve that accuracy level.Given equivalent accuracy, a CNN architecture with fewer parameters has several advantages:\bulletMore efficient distributed training.Communication among servers is the limiting factor to the scalability of distributed CNN training.For distributed data-parallel training, communication overhead is directly proportional to the number of parameters in the model Iandola et al. (2016).In short, small models train faster due to requiring less communication.\bulletLess overhead when exporting new models to clients. For autonomous driving, companies such as Tesla periodically copy new models from their servers to customers’ cars. This practice is often referred to as an over-the-air update. Consumer Reports has found that the safety of Tesla’s Autopilot semi-autonomous driving functionality has incrementally improved with recent over-the-air updates Consumer Reports (2016). However, over-the-air updates of today’s typical CNN/DNN models can require large data transfers. With AlexNet, this would require 240MB of communication from the server to the car. Smaller models require less communication, making frequent updates more feasible.\bulletFeasible FPGA and embedded deployment. FPGAs often have less than 10MB111For example, the Xilinx Vertex-7 FPGA has a maximum of 8.5 MBytes (i.e. 68 Mbits) of on-chip memory and does not provide off-chip memory. of on-chip memory and no off-chip memory or storage. For inference, a sufficiently small model could be stored directly on the FPGA instead of being bottlenecked by memory bandwidth Qiu et al. (2016), while video frames stream through the FPGA in real time.Further, when deploying CNNs on Application-Specific Integrated Circuits (ASICs), a sufficiently small model could be stored directly on-chip, and smaller models may enable the ASIC to fit on a smaller die.",8.5 MBytes.,0.1249999983007812,0.0571428560653061,0.1249999983007812,0.9896324688555468,9.340613374780943,9.489080463744516,0.0262467191601049,0.0005878894767783,0.4155726730823517,1.1102230246251563e-16,0.5002182126045227,,0.020051778659162,0.1468886435031891,4,1.0,1.0,1.0,0.8994615007475253,0.5826087187387311,0.8304348749549244,0.3,0.1468886435031891
88,88,What is an example of an autonomous car that uses CNN?,Tesla ( Model S for example ) autopilot system uses a convolutional neural network to detect objects on its way.,"Much of the recent research on deep convolutional neural networks (CNNs) has focused on increasing accuracy on computer vision datasets.For a given accuracy level, there typically exist multiple CNN architectures that achieve that accuracy level.Given equivalent accuracy, a CNN architecture with fewer parameters has several advantages:\bulletMore efficient distributed training.Communication among servers is the limiting factor to the scalability of distributed CNN training.For distributed data-parallel training, communication overhead is directly proportional to the number of parameters in the model Iandola et al. (2016).In short, small models train faster due to requiring less communication.\bulletLess overhead when exporting new models to clients. For autonomous driving, companies such as Tesla periodically copy new models from their servers to customers’ cars. This practice is often referred to as an over-the-air update. Consumer Reports has found that the safety of Tesla’s Autopilot semi-autonomous driving functionality has incrementally improved with recent over-the-air updates Consumer Reports (2016). However, over-the-air updates of today’s typical CNN/DNN models can require large data transfers. With AlexNet, this would require 240MB of communication from the server to the car. Smaller models require less communication, making frequent updates more feasible.\bulletFeasible FPGA and embedded deployment. FPGAs often have less than 10MB111For example, the Xilinx Vertex-7 FPGA has a maximum of 8.5 MBytes (i.e. 68 Mbits) of on-chip memory and does not provide off-chip memory. of on-chip memory and no off-chip memory or storage. For inference, a sufficiently small model could be stored directly on the FPGA instead of being bottlenecked by memory bandwidth Qiu et al. (2016), while video frames stream through the FPGA in real time.Further, when deploying CNNs on Application-Specific Integrated Circuits (ASICs), a sufficiently small model could be stored directly on-chip, and smaller models may enable the ASIC to fit on a smaller die.",Tesla.,0.0952380943310657,0.0,0.0952380943310657,2.159701133933343,12.237744293584262,13.716783678932654,0.0523560209424083,0.0004997501249375,0.4138291478157043,1.0,0.4138292074203491,,0.0162390175796653,0.7882314920425415,3,0.0,1.0,0.0,0.7578962647139643,0.7100149492810801,0.8401243857065053,0.8,0.7882314920425415
89,89,High accuracy is crucial for safety in autonomous vehicles. Would deploying smaller models using over-the-air updates in Tesla result in a trade-off with accuracy(and hence safety)?,"Accuracy is crucial for safety but it's not only accuracy vs size relation. We should consider more aspects. For example, response time of a driving car system is very crucial for safety. Communication overhead between servers while model training increases with the size of the model so smaller models train faster. Updating models from company servers to the car or over-the-air updates based on AlexNet at that time would require 240MB of communication from the server to the car. Hence, smaller models require less communication, making frequent updates more feasible. Also, keeping in mind architectural designs such as adjusting some functionalities, introducing new ways of extracting features, or using different objectives and optimizers may make a small model achieve the same level of accuracy or even surpass the larger model; for instance, SqueezeNet is 50x smaller than AlexNet with equivalent accuracy.","Much of the recent research on deep convolutional neural networks (CNNs) has focused on increasing accuracy on computer vision datasets.For a given accuracy level, there typically exist multiple CNN architectures that achieve that accuracy level.Given equivalent accuracy, a CNN architecture with fewer parameters has several advantages:\bulletMore efficient distributed training.Communication among servers is the limiting factor to the scalability of distributed CNN training.For distributed data-parallel training, communication overhead is directly proportional to the number of parameters in the model Iandola et al. (2016).In short, small models train faster due to requiring less communication.\bulletLess overhead when exporting new models to clients. For autonomous driving, companies such as Tesla periodically copy new models from their servers to customers’ cars. This practice is often referred to as an over-the-air update. Consumer Reports has found that the safety of Tesla’s Autopilot semi-autonomous driving functionality has incrementally improved with recent over-the-air updates Consumer Reports (2016). However, over-the-air updates of today’s typical CNN/DNN models can require large data transfers. With AlexNet, this would require 240MB of communication from the server to the car. Smaller models require less communication, making frequent updates more feasible.\bulletFeasible FPGA and embedded deployment. FPGAs often have less than 10MB111For example, the Xilinx Vertex-7 FPGA has a maximum of 8.5 MBytes (i.e. 68 Mbits) of on-chip memory and does not provide off-chip memory. of on-chip memory and no off-chip memory or storage. For inference, a sufficiently small model could be stored directly on the FPGA instead of being bottlenecked by memory bandwidth Qiu et al. (2016), while video frames stream through the FPGA in real time.Further, when deploying CNNs on Application-Specific Integrated Circuits (ASICs), a sufficiently small model could be stored directly on-chip, and smaller models may enable the ASIC to fit on a smaller die.
So far, we have proposed architectural design strategies for small models, followed these principles to create SqueezeNet, and discovered that SqueezeNet is 50x smaller than AlexNet with equivalent accuracy.However, SqueezeNet and other models reside in a broad and largely unexplored design space of CNN architectures.Now, in Sections 5 and 6, we explore several aspects of the design space. We divide this architectural exploration into two main topics: microarchitectural exploration (per-module layer dimensions and configurations) and macroarchitectural exploration (high-level end-to-end organization of modules and other layers). ",No.,0.0,0.0,0.0,0.2288431380440836,0.6337135614702154,0.999743037934025,0.0035335689045936,7.091695624423799e-05,0.036112081259489,0.2202344238758087,0.1434347182512283,,0.0018062393665502,0.0584238208830356,1,0.0,0.0,0.0,0.0,0.3153183137005751,0.7158146548770548,0.0,0.0584238208830356
90,90,What is an example of an FPGA?,Xilinx Vertex-7 FPGA which has a maximum of 8.5 MB (i.e. 68 Mbits) of on-chip memory and does not provide off-chip memory.,"Much of the recent research on deep convolutional neural networks (CNNs) has focused on increasing accuracy on computer vision datasets.For a given accuracy level, there typically exist multiple CNN architectures that achieve that accuracy level.Given equivalent accuracy, a CNN architecture with fewer parameters has several advantages:\bulletMore efficient distributed training.Communication among servers is the limiting factor to the scalability of distributed CNN training.For distributed data-parallel training, communication overhead is directly proportional to the number of parameters in the model Iandola et al. (2016).In short, small models train faster due to requiring less communication.\bulletLess overhead when exporting new models to clients. For autonomous driving, companies such as Tesla periodically copy new models from their servers to customers’ cars. This practice is often referred to as an over-the-air update. Consumer Reports has found that the safety of Tesla’s Autopilot semi-autonomous driving functionality has incrementally improved with recent over-the-air updates Consumer Reports (2016). However, over-the-air updates of today’s typical CNN/DNN models can require large data transfers. With AlexNet, this would require 240MB of communication from the server to the car. Smaller models require less communication, making frequent updates more feasible.\bulletFeasible FPGA and embedded deployment. FPGAs often have less than 10MB111For example, the Xilinx Vertex-7 FPGA has a maximum of 8.5 MBytes (i.e. 68 Mbits) of on-chip memory and does not provide off-chip memory. of on-chip memory and no off-chip memory or storage. For inference, a sufficiently small model could be stored directly on the FPGA instead of being bottlenecked by memory bandwidth Qiu et al. (2016), while video frames stream through the FPGA in real time.Further, when deploying CNNs on Application-Specific Integrated Circuits (ASICs), a sufficiently small model could be stored directly on-chip, and smaller models may enable the ASIC to fit on a smaller die.",The answer is Xilinx Vertex-7.,0.1481481451303155,0.0740740715500686,0.1481481451303155,2.955622941561161,34.64761537102205,31.240157650434845,0.1064814814814814,0.0022675736961451,0.5733544230461121,0.3532091828643299,0.6617043614387512,0.0645566582679748,0.1188627260243535,0.4373239278793335,4,0.0,4.0,1.0,0.0,0.5892259278170777,0.8568681594675098,1.0,0.4373239278793335
91,91,What is an example of model compression approaches?,"different examples can be: Applying SVD to a pretrained CNN model through which we can obtain most effective parameters or features of largest singular values of this factorization if we want. Information reconstruction of a matrix factorized with SVD  allow decreasing its rank, hence decreasing the memory allocated to save the vectors of these parameters . Also Network Pruning, which begins with a pretrained model, then replaces parameters that are below a certain threshold with zeros to form a sparse matrix, and finally performs a few iterations of training on the sparse CNN Maybe seen as another example . Deep compression -utilizing Huffman encoding, Network Pruning and quantization- yet is a third example.","The overarching goal of our work is to identify a model that has very few parameters while preserving accuracy.To address this problem, a sensible approach is to take an existing CNN model and compress it in a lossy fashion.In fact, a research community has emerged around the topic of model compression, and several approaches have been reported.A fairly straightforward approach by Denton et al. is to apply singular value decomposition (SVD) to a pretrained CNN model Denton et al. (2014).Han et al. developed Network Pruning, which begins with a pretrained model, then replaces parameters that are below a certain threshold with zeros to form a sparse matrix, and finally performs a few iterations of training on the sparse CNN Han et al. (2015b).Recently, Han et al. extended their work by combining Network Pruning with quantization (to 8 bits or less) and huffman encoding to create an approach called Deep Compression Han et al. (2015a), and further designed a hardware accelerator called EIE Han et al. (2016a) that operates directly on the compressed model, achieving substantial speedups and energy savings.","SVD, Network Pruning, Deep Compression.",0.0689655161580129,0.0176991143613439,0.0689655161580129,1.7914550987060265,16.31680412176987,16.32118848897376,0.0575432999088422,0.0004543389368468,0.6045178174972534,1.0,0.6746801137924194,0.3801149129867553,0.1229098134348993,0.2047610133886337,4,1.0,5.0,1.0,0.9381969509149926,0.6720310523168406,0.8881242092673625,0.0,0.2047610133886337
92,92,"What is an example of a ""module"" in CNN?","a module can be thought of as a block of some several layers may be of different filter sizes and dimensions to perform some specific functionality. Many such modules are then combined to form a complete network. For example, Inception modules, which are comprised of a number of different dimensionalities of filters, like 1x1 and 3x3, sometimes 5x5, 1x3 and 3x1.","With the trend of designing very deep CNNs, it becomes cumbersome to manually select filter dimensions for each layer.To address this, various higher level building blocks, or modules, comprised of multiple convolution layers with a specific fixed organization have been proposed.For example, the GoogLeNet papers propose Inception modules, which are comprised of a number of different dimensionalities of filters, usually including 1x1 and 3x3, plus sometimes 5x5 Szegedy et al. (2014) and sometimes 1x3 and 3x1 Szegedy et al. (2015).Many such modules are then combined, perhaps with additional ad-hoc layers, to form a complete network.We use the term CNN microarchitecture to refer to the particular organization and dimensions of the individual modules.",The answer is Inception module.,0.078431370780469,0.0,0.078431370780469,0.6894315196865248,19.281380198333885,16.47801961366643,0.0318979266347687,0.0008326394671107,0.5296797156333923,0.7101630411183524,0.5868545770645142,0.5249298810958862,0.0264332094233092,0.1980655938386917,3,1.0,4.0,1.0,0.8362530863778765,0.5856591704935643,0.842636681974257,1.0,0.1980655938386917
93,93,What is an example of a DSE approach?,"An example of DSE approach can be  Bayesian optimization, simulated annealing, randomized search or genetic algorithms and all tend to develop automated approaches to find NN architectures exhibiting higher accuracy.","Neural networks (including deep and convolutional NNs) have a large design space, with numerous options for microarchitectures, macroarchitectures, solvers, and other hyperparameters.It seems natural that the community would want to gain intuition about how these factors impact a NN’s accuracy (i.e. the shape of the design space).Much of the work on design space exploration (DSE) of NNs has focused on developing automated approaches for finding NN architectures that deliver higher accuracy.These automated DSE approaches include bayesian optimization Snoek et al. (2012), simulated annealing Ludermir et al. (2006), randomized search Bergstra & Bengio (2012), and genetic algorithms Stanley & Miikkulainen (2002).To their credit, each of these papers provides a case in which the proposed DSE approach produces a NN architecture that achieves higher accuracy compared to a representative baseline.However, these papers make no attempt to provide intuition about the shape of the NN design space.Later in this paper, we eschew automated approaches – instead, we refactor CNNs in such a way that we can do principled A/B comparisons to investigate how CNN architectural decisions influence model size and accuracy.",Bayesian optimization.,0.0645161278251821,0.0,0.0645161278251821,2.485828141410168,34.265306235408424,31.501426174691773,0.0851851851851852,0.0006891798759476,0.4004707038402557,1.0,0.4004706740379333,0.6948093175888062,0.0362320910922347,0.2806761860847473,4,1.0,4.0,1.0,0.8075093025537651,0.5812205161133224,0.8248820644532893,0.75,0.2806761860847473
94,94,What is the ratio of 1x1 filters in the total number of filters?,"The question needs to be related to some certain context but if we consider asking about the ratio of 1*1 filters in each fire module then the answer would be as follows: for a fire module ratio of 1*1 filters w.r.t. all filters can be calculated as (s1x1+e1x1)/(s1x1+e1x1+e3x3) where; s1x1 is the number of filters in the squeeze layer,e1x1 is the number of 1x1 filters in the expand layer, and e3x3 is the number of 3x3 filters in the expand layer. It is also worth to mention that s1x1 is to be less than (e1x1 + e3x3), so the squeeze layer helps to limit the number of input channels to the 3x3 filters.","We define the Fire module as follows.A Fire module is comprised of: a squeeze convolution layer (which has only 1x1 filters), feeding into an expand layer that has a mix of 1x1 and 3x3 convolution filters; we illustrate this in Figure 1.The liberal use of 1x1 filters in Fire modules is an application of Strategy 1 from Section 3.1.We expose three tunable dimensions (hyperparameters) in a Fire module: s_{1x1}, e_{1x1}, and e_{3x3}.In a Fire module, s_{1x1} is the number of filters in the squeeze layer (all 1x1), e_{1x1} is the number of 1x1 filters in the expand layer, and e_{3x3} is the number of 3x3 filters in the expand layer.When we use Fire modules we set s_{1x1} to be less than (e_{1x1} + e_{3x3}), so the squeeze layer helps to limit the number of input channels to the 3x3 filters, as per Strategy 2 from Section 3.1.",e_{1x1} / (e_{1x1} + e_{3x3} + s_{1x1}).,0.02777777625,0.0,0.02777777625,0.7017759864762021,4.906838930985696,4.44202430664047,0.0285016286644951,0.0006246096189881,0.3004384934902191,0.3244147157190635,0.4471970498561859,,0.0680065590976384,0.09943188726902,3,0.0,4.0,1.0,0.7633141911333868,0.9046957774552664,0.8495523405902963,0.8,0.09943188726902
95,95,"How does the choice of layers, in which to downsample, affect the size of activation maps?","As we can see, downsampling aim to collect summary about statistics of different regions of some feature map, and this can be addressed with stride >1 in convolution or pooling layers which affects the size of activation map. If early layers  have large strides, then most layers will have small activation maps and if most layers in the network have a stride of 1, and the strides greater than 1 are later in the network, then many layers in the network will have large activation maps.","Strategy 3. Downsample late in the network so that convolution layers have large activation maps.In a convolutional network, each convolution layer produces an output activation map with a spatial resolution that is at least 1x1 and often much larger than 1x1.The height and width of these activation maps are controlled by: (1) the size of the input data (e.g. 256x256 images) and (2) the choice of layers in which to downsample in the CNN architecture.Most commonly, downsampling is engineered into CNN architectures by setting the (stride > 1) in some of the convolution or pooling layers (e.g. Szegedy et al. (2014); Simonyan & Zisserman (2014); Krizhevsky et al. (2012)).If early333In our terminology, an “early” layer is close to the input data. layers in the network have large strides, then most layers will have small activation maps.Conversely, if most layers in the network have a stride of 1, and the strides greater than 1 are concentrated toward the end444In our terminology, the “end” of the network is the classifier. of the network, then many layers in the network will have large activation maps.Our intuition is that large activation maps (due to delayed downsampling) can lead to higher classification accuracy, with all else held equal.Indeed, K. He and H. Sun applied delayed downsampling to four different CNN architectures, and in each case delayed downsampling led to higher classification accuracy He & Sun (2015).",It controls the size of activation maps.,0.1562499980517578,0.096385540827406,0.1562499980517578,3.3300489840975613,23.93536833872478,23.51427220667317,0.0670314964393251,0.0008634513383495,0.3775284588336944,0.8179939091205597,0.4854651093482971,0.6230244636535645,0.0724845718231978,0.0651665925979614,1,1.0,1.0,1.0,0.7999733382997823,0.4192299846847481,0.8197770815961356,0.8,0.0651665925979614
96,96,Why did the authors use a mix of 1x1 and 3x3 filters in the expand layer of fire module?,"Authors used a mix of 1x1 and 3x3 filters in the expand layer of the fire module to reduce the number of parameters while still getting benefits from the desired properties of having reasonable scope of the input receptive field and extracting correlations and useful information by applying the 3*3 filters of the CNN. To have a small number of parameters in a CNN, we need to decrease the number of input channels to the 3x3 filters and here comes the role of 1*1 filters, while the 3x3 filters are used to capture larger spatial features (Assuming only 3*3 and 1*1 kernels). This way, the model get its wide fame of achieving a high level of accuracy with fewer parameters than other networks.","Strategy 2. Decrease the number of input channels to 3x3 filters.Consider a convolution layer that is comprised entirely of 3x3 filters.The total quantity of parameters in this layer is (number of input channels) * (number of filters) * (3*3).So, to maintain a small total number of parameters in a CNN, it is important not only to decrease the number of 3x3 filters (see Strategy 1 above), but also to decrease the number of input channels to the 3x3 filters.We decrease the number of input channels to 3x3 filters using squeeze layers, which we describe in the next section. 
We define the Fire module as follows.A Fire module is comprised of: a squeeze convolution layer (which has only 1x1 filters), feeding into an expand layer that has a mix of 1x1 and 3x3 convolution filters; we illustrate this in Figure 1.The liberal use of 1x1 filters in Fire modules is an application of Strategy 1 from Section 3.1.We expose three tunable dimensions (hyperparameters) in a Fire module: s_{1x1}, e_{1x1}, and e_{3x3}.In a Fire module, s_{1x1} is the number of filters in the squeeze layer (all 1x1), e_{1x1} is the number of 1x1 filters in the expand layer, and e_{3x3} is the number of 3x3 filters in the expand layer.When we use Fire modules we set s_{1x1} to be less than (e_{1x1} + e_{3x3}), so the squeeze layer helps to limit the number of input channels to the 3x3 filters, as per Strategy 2 from Section 3.1.",To apply Strategy 1 from Section 3.1.,0.0476190460912698,0.0,0.0476190460912698,0.3636483855236668,7.328947855052842,6.657612434900623,0.0198570293884034,0.0005781779136037,0.159365102648735,0.5147379188411004,0.189311996102333,0.250315248966217,0.0024013619875892,0.061412401497364,1,1.0,0.0,,0.7406768477693912,0.8322528198532595,0.7575196595570146,0.0,0.061412401497364
97,97,What is the total number of filters in squeeze convolution layer?,s1x1 is the number of filters in the squeeze layer and it is set s1x1 to be less than (e1x1 + e3x3) -the total number of filters in expand layer of the fire module- to limit the number of input channels to the 3x3 filters.,"We define the Fire module as follows.A Fire module is comprised of: a squeeze convolution layer (which has only 1x1 filters), feeding into an expand layer that has a mix of 1x1 and 3x3 convolution filters; we illustrate this in Figure 1.The liberal use of 1x1 filters in Fire modules is an application of Strategy 1 from Section 3.1.We expose three tunable dimensions (hyperparameters) in a Fire module: s_{1x1}, e_{1x1}, and e_{3x3}.In a Fire module, s_{1x1} is the number of filters in the squeeze layer (all 1x1), e_{1x1} is the number of 1x1 filters in the expand layer, and e_{3x3} is the number of 3x3 filters in the expand layer.When we use Fire modules we set s_{1x1} to be less than (e_{1x1} + e_{3x3}), so the squeeze layer helps to limit the number of input channels to the 3x3 filters, as per Strategy 2 from Section 3.1.",s_{1x1}.,0.0,0.0,0.0,0.7605497822189857,3.217521408053177,3.490909296528294,0.011441647597254,0.0002221728504776,0.429665595293045,0.1054968947455997,0.4296656250953674,,0.0400183409550398,0.1885424703359604,3,1.0,4.0,1.0,0.7196852991611143,0.8061763019330546,0.8247052077322179,1.0,0.1885424703359604
98,98,"The Caffe framework does not natively support a convolution layer that contains multiple filter resolutions .To get around this, the authors implement the expand layer with two separate convolution layers. What is the additional cost incurred by using two convolution layers?","The additional cost of using 2 convolutional layers may be that the parameters of the 2 layers are now trained separately; they are not benefiting from each other being jointly optimized to perform some task and share useful information between each other while training, but output shape is still not affected by the separation i.e.,this is numerically equivalent to have one layer that contains both 1x1 and 3x3 filters.","\bulletSo that the output activations from 1x1 and 3x3 filters have the same height and width, we add a 1-pixel border of zero-padding in the input data to 3x3 filters of expand modules.\bulletReLU Nair & Hinton (2010) is applied to activations from squeeze and expand layers.\bulletDropout Srivastava et al. (2014) with a ratio of 50% is applied after the fire9 module.\bulletNote the lack of fully-connected layers in SqueezeNet; this design choice was inspired by the NiN Lin et al. (2013) architecture.\bulletWhen training SqueezeNet, we begin with a learning rate of 0.04, and we linearly decrease the learning rate throughout training, as described in Mishkin et al. (2016).For details on the training protocol (e.g. batch size, learning rate, parameter initialization), please refer to our Caffe-compatible configuration files located here: https://github.com/DeepScale/SqueezeNet.\bulletThe Caffe framework does not natively support a convolution layer that contains multiple filter resolutions (e.g. 1x1 and 3x3) Jia et al. (2014). To get around this, we implement our expand layer with two separate convolution layers: a layer with 1x1 filters, and a layer with 3x3 filters. Then, we concatenate the outputs of these layers together in the channel dimension. This is numerically equivalent to implementing one layer that contains both 1x1 and 3x3 filters.","None, as the outputs are concatenated.",0.0624999983007813,0.0,0.0624999983007813,0.6623242848001161,14.05185578465269,12.959493070003386,0.0370919881305637,0.000894721145243,0.2403590530157089,0.7117861472070217,0.2403590232133865,0.6171441674232483,0.0182653937952063,0.0689567402005195,3,0.5,1.0,0.6666666666666666,0.7215338215603523,0.4933524602874903,0.7734098411499611,0.0,0.0689567402005195
99,99,Did the authors use AlexNet for evaluation of SqueezeNet?,"Yes, as told by authors that they used AlexNet and the associated model compression results as a basis for comparison when evaluating SqueezeNet.","We now turn our attention to evaluating SqueezeNet.In each of the CNN model compression papers reviewed in Section 2.1, the goal was to compress an AlexNet Krizhevsky et al. (2012) model that was trained to classify images using the ImageNet Deng et al. (2009) (ILSVRC 2012) dataset.Therefore, we use AlexNet555Our baseline is bvlc_alexnet from the Caffe codebase Jia et al. (2014). and the associated model compression results as a basis for comparison when evaluating SqueezeNet.",Yes.,0.0,0.0,0.0,1.7911710595643588,6.464850442506428,9.743233495556638,0.0440528634361233,0.0004345936549326,0.1712381988763809,1.0,0.1712381839752197,,0.0270709409921761,0.606420636177063,4,0.0,2.0,,0.8707686858768039,0.699577317579416,0.7983092703176642,1.0,0.606420636177063
